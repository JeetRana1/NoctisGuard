<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Server Dashboard - NoctisGuard</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="icon" href="/favicon.svg" sizes="any">
  <link rel="shortcut icon" href="/favicon.svg">
  <link rel="apple-touch-icon" href="/favicon.svg">
</head>

<body>
  <nav class="container" style="padding-top:24px;display:flex;align-items:center;gap:12px"><a id="back-btn"
      href="dashboard.html" class="btn ghost">‚Üê Back</a>
    <h2 style="margin:0">Server Dashboard</h2>
  </nav>

  <div class="container dashboard-main">
    <div id="server-header" class="server-dashboard-header">
      <div class="server-avatar"><img src="placeholder.svg" alt="Server Avatar"
          style="width:56px;height:56px;border-radius:8px"></div>
      <div class="server-meta">
        <h2 id="server-title">Server</h2>
        <div class="small-muted" id="server-sub">Manage plugins & settings</div>
      </div>
    </div>

    <section>
      <h3 class="section-title">Plugins</h3>
      <p class="section-lead">Enable or configure plugins for this server. Changes are saved to the server.</p>

      <div id="plugin-grid" class="plugin-grid"></div>

      <div id="activity-and-members" style="display:flex;gap:20px;margin-top:20px;align-items:flex-start">
        <div style="flex:1;min-width:320px">
          <h4 style="margin:0 0 8px">Activity Feed</h4>
          <div id="activity-feed" class="card preview"
            style="min-height:120px;padding:12px;overflow:auto;max-height:260px"></div>
        </div>
        <div style="width:320px">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
            <h4 style="margin:0">Members</h4><button id="refresh-members" class="btn ghost">Refresh</button>
          </div>
          <div id="members-list" class="card preview"
            style="min-height:120px;padding:12px;overflow:auto;max-height:260px"></div>
        </div>
      </div>
    </section>
  </div>

  <script src="script.js"></script>
  <script>
    // Plugins limited to Moderation, Levels, and Giveaways
    // Add `icon` property (emoji or inline SVG) for a nicer UI
    const PLUGINS = [
      { id: 'moderation', title: 'Moderation', description: 'Auto moderation and moderation tools', icon: 'üõ°Ô∏è' },
      { id: 'leveling', title: 'Levels', description: 'XP and level rewards for active members', icon: '‚≠ê' },
      { id: 'giveaways', title: 'Giveaways', description: 'Create and manage giveaways', icon: 'üéâ' },
      { id: 'misc', title: 'Misc', description: 'Utility commands and helpers (timers, reminders, etc.)', icon: 'üß∞' },
      { id: 'info', title: 'Info', description: 'Server and bot information commands (stats, uptime, version)', icon: '‚ÑπÔ∏è' },
      { id: 'welcome', title: 'Welcome', description: 'Welcome messages, auto-roles and greeting configuration', icon: 'üéä' }
    ];

    // Helper to construct a Discord avatar CDN URL (handles animated avatars)
    function discordAvatarUrl(id, hash, size) {
      if (!hash) return null;
      const h = String(hash);
      const ext = h.startsWith('a_') ? 'gif' : 'png';
      return `https://cdn.discordapp.com/avatars/${id}/${hash}.${ext}?size=${size || 64}`;
    }

    // close helpers
    window.closePluginConfig = function () { const modal = document.getElementById('plugin-modal'); if (!modal) return; modal.setAttribute('aria-hidden', 'true'); setTimeout(() => { modal.style.display = 'none'; }, 220); };
    window.closeWelcomeConfig = function () { const modal = document.getElementById('plugin-modal-welcome'); if (!modal) return; modal.setAttribute('aria-hidden', 'true'); setTimeout(() => { modal.style.display = 'none'; }, 220); };
    window.closeGiveawayConfig = function () { const modal = document.getElementById('plugin-modal-giveaway'); if (!modal) return; modal.setAttribute('aria-hidden', 'true'); setTimeout(() => { modal.style.display = 'none'; }, 220); };

    const params = new URLSearchParams(location.search);
    const serverId = params.get('id') || 'unknown';
    let serverName = params.get('name') || 'Server';

    // Try to fetch the server's real name from /api/guild/:id so redirects without a 'name' param still show correctly
    (async function fetchAndSetServerInfo() {
      try {
        const r = await fetch(`/api/guild/${encodeURIComponent(serverId)}`, { credentials: 'include' });
        if (!r.ok) return;
        const me = await r.json();
        if (me) {
          serverName = me.name || serverName; const el = document.getElementById('server-title'); if (el) el.textContent = serverName;
          try {
            const av = document.querySelector('.server-avatar img'); if (av) {
              if (me.icon) { const ext = (me.icon && me.icon.startsWith && me.icon.startsWith('a_')) ? 'gif' : 'png'; av.src = `https://cdn.discordapp.com/icons/${me.id}/${me.icon}.${ext}?size=128`; }
              else { av.src = 'placeholder.svg'; }
              try { if (typeof setImageFallback === 'function') setImageFallback(av); } catch (e) { }
            }
          } catch (e) { }
        }
      } catch (e) { console.warn('Failed to fetch guild name for server-dashboard', e); }
    })();

    // Early safety: define a minimal `safeShowWinnersModal` so handlers can call it before the full modal is initialized
    if (!window.safeShowWinnersModal) {
      window.safeShowWinnersModal = function (gid, winnerIds) {
        try {
          if (typeof window.showWinnersModal === 'function') return window.showWinnersModal(gid, winnerIds);
        } catch (e) {
          // If showWinnersModal failed, and we were given resolved member objects, retry with IDs
          try {
            if (Array.isArray(winnerIds) && winnerIds.length && typeof winnerIds[0] === 'object') {
              const ids = winnerIds.map(w => (w && w.id) ? String(w.id) : null).filter(Boolean);
              if (ids.length) return window.showWinnersModal(gid, ids);
            }
          } catch (e2) { }
        }
        try {
          const existing = document.getElementById('winners-modal-overlay'); if (existing) existing.remove();
          const overlay = document.createElement('div'); overlay.id = 'winners-modal-overlay'; overlay.className = 'winners-modal-overlay';
          const card = document.createElement('div'); card.className = 'winners-modal-card';
          const title = document.createElement('h4'); title.textContent = gid ? ('Winners for #' + gid) : 'Winners';

          // Build a nicer list view (supports resolved member objects with avatar + username)
          const list = document.createElement('div'); list.id = 'winners-modal-list'; list.className = 'winners-modal-list';
          if (Array.isArray(winnerIds) && winnerIds.length) {
            winnerIds.forEach(w => {
              try {
                const id = (w && typeof w === 'object' && w.id) ? String(w.id) : (typeof w === 'string' ? w : String(w));
                const row = document.createElement('div'); row.className = 'winner-row';
                const avatar = document.createElement('div'); avatar.className = 'winner-avatar placeholder'; avatar.setAttribute('data-winner-id', id);
                // placeholder text (first char of username or '?')
                avatar.textContent = (w && w.username) ? (w.username[0] || '?').toUpperCase() : (id ? id[0] : '?');

                const meta = document.createElement('div'); meta.className = 'winner-meta';
                const userLine = document.createElement('div'); userLine.className = 'winner-field';
                const userLabel = document.createElement('span'); userLabel.className = 'winner-label'; userLabel.textContent = 'User: ';
                const mention = document.createElement('a'); mention.className = 'winner-mention'; mention.target = '_blank'; mention.rel = 'noopener noreferrer';
                if (w && typeof w === 'object' && w.username) { mention.href = 'https://discord.com/users/' + id; mention.textContent = '@' + w.username; }
                else { mention.href = 'https://discord.com/users/' + id; mention.textContent = '@' + id; }
                mention.setAttribute('data-winner-id', id);
                userLine.appendChild(userLabel); userLine.appendChild(mention);

                const idLine = document.createElement('div'); idLine.className = 'winner-field';
                const idLabel = document.createElement('span'); idLabel.className = 'winner-label'; idLabel.textContent = 'ID: ';
                const idVal = document.createElement('span'); idVal.className = 'winner-id'; idVal.textContent = id;
                idLine.appendChild(idLabel); idLine.appendChild(idVal);

                meta.appendChild(userLine); meta.appendChild(idLine);
                row.appendChild(avatar); row.appendChild(meta);

                // if we have an avatar hash, set it now
                if (w && w.avatar) { const _u = discordAvatarUrl(id, w.avatar, 64); if (_u) { avatar.style.backgroundImage = 'url(' + _u + ')'; avatar.style.backgroundSize = 'cover'; avatar.classList.remove('placeholder'); avatar.textContent = ''; } }

                list.appendChild(row);
              } catch (e) { const row = document.createElement('div'); row.textContent = String(w); list.appendChild(row); }
            });
          } else {
            const p = document.createElement('p'); p.className = 'winners-empty'; p.textContent = String(winnerIds || 'No winners'); list.appendChild(p);
          }

          const actions = document.createElement('div'); actions.className = 'winners-modal-actions';
          const copy = document.createElement('button'); copy.className = 'btn ghost'; copy.id = 'winners-copy-all'; copy.textContent = 'Copy All IDs'; copy.onclick = () => { try { if (Array.isArray(winnerIds)) { const ids = winnerIds.map(w => (w && typeof w === 'object' && w.id) ? String(w.id) : String(w)).join('\n'); navigator.clipboard && navigator.clipboard.writeText(ids); } else { navigator.clipboard && navigator.clipboard.writeText(String(winnerIds || '')); } } catch (e) { } };
          const close = document.createElement('button'); close.className = 'btn'; close.id = 'winners-close'; close.textContent = 'Close'; close.onclick = () => { overlay.remove(); };
          actions.appendChild(copy); actions.appendChild(close);

          card.appendChild(title); card.appendChild(list); card.appendChild(actions); overlay.appendChild(card); document.body.appendChild(overlay);
          overlay.addEventListener('click', (ev) => { if (ev.target === overlay) overlay.remove(); });
        } catch (e) { try { if (typeof showToast === 'function') showToast('Winners: ' + (Array.isArray(winnerIds) ? winnerIds.join(', ') : String(winnerIds || '')), 'info'); } catch (e) { } }
      };
    }

    // Safety fallback: define a global refresh function early so it can be called from DevTools
    // even if the giveaway modal isn't initialized yet. The modal will override this later.
    if (!window.refreshGiveawayActivity) {
      window.refreshGiveawayActivity = async function () {
        console.log('refreshGiveawayActivity fallback: fetching giveaways and activity for', serverId);
        try {
          const [gRes, aRes] = await Promise.all([
            fetch(`/api/server-giveaways/${encodeURIComponent(serverId)}`, { credentials: 'include' }).catch(e => ({ ok: false, error: e })),
            fetch(`/api/server-activity/${encodeURIComponent(serverId)}`, { credentials: 'include' }).catch(e => ({ ok: false, error: e }))
          ]);
          const gTxt = gRes && gRes.ok ? await gRes.text().catch(() => null) : (gRes && gRes.error ? String(gRes.error) : null);
          const aTxt = aRes && aRes.ok ? await aRes.text().catch(() => null) : (aRes && aRes.error ? String(aRes.error) : null);
          console.log('GIVEAWAYS status', gRes && gRes.status, 'preview:', gTxt ? gTxt.slice(0, 1000) : '<no body>');
          console.log('ACTIVITY status', aRes && aRes.status, 'preview:', aTxt ? aTxt.slice(0, 1000) : '<no body>');

          // If modal's real renderer exists, call it (it should expose a modal-scoped function _modalRefreshGiveawayActivity)
          if (typeof window._modalRefreshGiveawayActivity === 'function' && document.getElementById('plugin-modal-giveaway')) {
            try { /* prefer the in-modal renderer if available */
              // If the modal has its own internal version, it'll set _modalRefreshGiveawayActivity; call it after a short delay
              await new Promise(r => setTimeout(r, 80));
              if (typeof window._modalRefreshGiveawayActivity === 'function') {
                console.log('Calling modal-provided _modalRefreshGiveawayActivity');
                try { window._modalRefreshGiveawayActivity(); } catch (e) { }
              }
            } catch (e) { }
          } else {
            // If there's a list element on the page, try to render a very small debug view
            const el = document.getElementById('giveaway-activity-list');
            if (el) {
              el.innerHTML = '<p class="small-muted">Debug: fetching raw data (see console)...</p>';
              try {
                const gObj = gTxt ? JSON.parse(gTxt) : null;
                const aObj = aTxt ? JSON.parse(aTxt) : null;
                el.innerHTML = '';
                if (gObj || aObj) {
                  try {
                    const gArr = (gObj && Array.isArray(gObj.giveaways)) ? gObj.giveaways : [];
                    const aArr = (aObj && Array.isArray(aObj.activity)) ? aObj.activity : [];
                    if (typeof window.forceRenderActivity === 'function') {
                      try { window.forceRenderActivity(gArr, aArr); }
                      catch (e) { console.warn('forceRenderActivity failed in fallback', e); }
                    } else {
                      const outRoot = document.getElementById('giveaway-activity-inner') || el;
                      const h = document.createElement('div'); h.innerHTML = '<strong>Running Giveaways (debug)</strong>'; outRoot.appendChild(h);
                      gArr.forEach(g => { const d = document.createElement('div'); d.textContent = `#${g.id || g.giveawayId} ${g.prize || ''}`; outRoot.appendChild(d); });
                      const h2 = document.createElement('div'); h2.style.marginTop = '8px'; h2.innerHTML = '<strong>Recent Activity (debug)</strong>'; outRoot.appendChild(h2);
                      aArr.slice(0, 20).forEach(a => { const d = document.createElement('div'); d.textContent = `${a.type} ${a.pluginId || ''} ${a.payload && a.payload.prize || ''}`; outRoot.appendChild(d); });
                    }
                  } catch (e) { el.innerHTML = '<p class="small-muted">No giveaways or recent activity found (debug view).</p>'; }
                } else { el.innerHTML = '<p class="small-muted">No giveaways or recent activity found (debug view).</p>'; }
              } catch (e) { el.innerHTML += '<p class="small-muted">Failed to parse JSON responses; see console.</p>'; }
            }
          }
        } catch (e) { console.warn('refreshGiveawayActivity fallback failed', e); }
      };
    }

    document.getElementById('server-title').textContent = serverName;

    // Helper: determine if modals should use the light modal styling based on server/global saved theme
    function modalShouldUseLight() {
      try { const sRaw = localStorage.getItem('ng_theme_' + serverId); if (sRaw) { const sObj = JSON.parse(sRaw); if (sObj && sObj.bgMode === 'light') return true; } } catch (e) { }
      try { const gRaw = localStorage.getItem('ng_theme_global'); if (gRaw) { const gObj = JSON.parse(gRaw); if (gObj && gObj.bgMode === 'light') return true; } } catch (e) { }
      const t = localStorage.getItem('ng_theme'); if (t === 'light') return true;
      return false;
    }
    function syncModalTheme(modal) {
      if (!modal) return; const isLight = modalShouldUseLight() || document.documentElement.classList.contains('theme-light'); console.log('syncModalTheme', { serverId: serverId, isLight }); modal.classList.toggle('light-theme', isLight);
      // Force inline styles for cases where CSS variables or rules are not applied
      const content = modal.querySelector('.modal-content');
      if (isLight) {
        modal.style.background = 'rgba(11,15,18,0.06)';
        if (content) { content.style.background = 'rgba(255,255,255,0.98)'; content.style.border = '1px solid rgba(16,20,24,0.06)'; content.style.color = 'var(--text)'; }
        modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(el => { el.style.background = 'rgba(255,255,255,0.98)'; el.style.color = 'var(--text)'; el.style.border = '1px solid rgba(16,20,24,0.06)'; });
      } else {
        modal.style.background = '';
        if (content) { content.style.background = ''; content.style.border = ''; content.style.color = ''; }
        modal.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(el => { el.style.background = ''; el.style.color = ''; el.style.border = ''; });
      }
    }

    // Ensure autofill styling persists when plugin modals are reopened
    function syncAutofillInModal(modal) {
      if (!modal) return;
      const isLight = modal.classList.contains('light-theme') || modalShouldUseLight();
      const inputs = modal.querySelectorAll('input[type="text"], input[type="number"], textarea');
      inputs.forEach(input => {
        try {
          const hasValue = input.value && String(input.value).trim() !== '';
          if (hasValue) {
            input.dataset.autofilled = 'true';
          } else {
            delete input.dataset.autofilled;
          }

          // Apply persistent inline styles for autofilled fields so browser UA styling doesn't override on reopen
          if (input.dataset.autofilled === 'true') {
            const docStyle = getComputedStyle(document.documentElement);
            const bg = isLight ? 'rgba(255,255,255,0.98)' : (docStyle.getPropertyValue('--card') || 'var(--card)');
            const txt = (docStyle.getPropertyValue('--text') || '#e9eef6').trim();
            const bdr = isLight ? '1px solid rgba(16,20,24,0.06)' : '1px solid var(--border)';
            try {
              // Apply inline styles immediately
              input.style.background = bg;
              input.style.color = txt;
              input.style.border = bdr;
              input.style.setProperty('box-shadow', 'inset 0 0 0 1000px ' + bg, 'important');
              input.style.setProperty('-webkit-box-shadow', 'inset 0 0 0 1000px ' + bg, 'important');
              input.style.setProperty('-webkit-text-fill-color', txt, 'important');
              // Workaround: briefly clear and restore the value to force the browser to drop its own autofill rendering
              // Only perform this once per-input per-modal open to avoid causing visible glitches while typing.
              if (!input.dataset._autofillSanitized) {
                const cur = input.value;
                try { input.value = ''; setTimeout(() => { input.value = cur; }, 20); } catch (e) { }
                input.dataset._autofillSanitized = '1';
              }
            } catch (e) { }
          } else {
            // Remove inline autofill styling if field cleared
            try {
              input.style.removeProperty('box-shadow');
              input.style.removeProperty('-webkit-box-shadow');
              input.style.removeProperty('background');
              input.style.removeProperty('color');
              input.style.removeProperty('-webkit-text-fill-color');
              delete input.dataset._autofillSanitized;
            } catch (e) { }
          }

          // Attach an input listener once so if the user edits/clears the field we update the attribute
          if (!input._autofillHandlerAttached) {
            input.addEventListener('input', () => {
              if (input.value && String(input.value).trim() !== '') {
                input.dataset.autofilled = 'true';
              } else {
                delete input.dataset.autofilled;
              }
              // Re-run styling logic for immediate visual feedback
              syncAutofillInModal(modal);
            });
            input._autofillHandlerAttached = true;
          }
        } catch (e) { /* ignore */ }
      });
    }

    // Force-render helper for activity lists (safe DOM creation, used by fallback & modal)
    window.forceRenderActivity = function (giveaways, activities) {
      try {
        const inner = document.getElementById('giveaway-activity-inner') || document.getElementById('giveaway-activity-list');
        if (!inner) return;
        inner.innerHTML = '';

        // Running Giveaways header
        const runHeader = document.createElement('div'); runHeader.style.marginBottom = '8px'; runHeader.innerHTML = '<strong style="display:block;margin-bottom:6px">Running Giveaways</strong>';
        inner.appendChild(runHeader);

        if (Array.isArray(giveaways) && giveaways.length) {
          giveaways.forEach(g => {
            try {
              const gid = g.id || g.giveawayId || ('g-' + (g.ts || Date.now()));
              const prize = g.prize || '(no prize)';
              const createdAt = g.createdAt ? new Date(g.createdAt) : (g.ts ? new Date(g.ts) : null);
              const endsAt = g.endsAt ? new Date(g.endsAt) : null;
              const creator = g.creatorName || (g.creator && g.creator.username) || (g.createdBy || g.creatorId) || 'Unknown';
              const channelText = (g.channel && (g.channel.name || g.channel.id)) ? (g.channel.name ? '#' + g.channel.name : '#' + g.channel.id) : (g.channelId ? '#' + g.channelId : '‚Äî');

              const card = document.createElement('div'); card.className = 'giveaway-item'; card.dataset.gid = gid;
              const leftDot = document.createElement('div'); leftDot.className = 'dot'; leftDot.style.background = (endsAt && Date.now() > endsAt.getTime()) ? 'var(--danger)' : '#3ad37f';
              const body = document.createElement('div'); body.style.flex = '1';
              const titleRow = document.createElement('div'); titleRow.style.display = 'flex'; titleRow.style.justifyContent = 'space-between'; titleRow.style.alignItems = 'center'; titleRow.style.gap = '8px';
              const title = document.createElement('div'); title.style.fontWeight = '700'; title.textContent = prize + ' '; const idSpan = document.createElement('span'); idSpan.className = 'small-muted'; idSpan.style.fontWeight = '400'; idSpan.textContent = '#' + gid; title.appendChild(idSpan);
              const created = document.createElement('div'); created.className = 'small-muted'; created.textContent = createdAt ? createdAt.toLocaleString() : '';
              titleRow.appendChild(title); titleRow.appendChild(created);
              const meta = document.createElement('div'); meta.className = 'small-muted'; meta.style.marginTop = '6px'; meta.textContent = 'By ';
              const strong = document.createElement('strong'); strong.textContent = creator; meta.appendChild(strong); meta.appendChild(document.createTextNode(' ¬∑ Channel: ' + channelText));
              const ends = document.createElement('div'); ends.className = 'small-muted'; ends.style.marginTop = '6px'; const endsText = document.createElement('span'); endsText.textContent = 'Ends: ' + (endsAt ? endsAt.toLocaleString() : '‚Äî'); ends.appendChild(endsText);

              const controls = document.createElement('div'); controls.style.display = 'flex'; controls.style.flexDirection = 'column'; controls.style.gap = '8px';
              const copyBtn = document.createElement('button'); copyBtn.className = 'btn ghost copy-id'; copyBtn.dataset.id = gid; copyBtn.textContent = 'Copy ID';
              const winnersBtn = document.createElement('button'); winnersBtn.className = 'btn ghost view-winners'; winnersBtn.dataset.id = gid; winnersBtn.textContent = 'Winners';
              const rerollBtn = document.createElement('button'); rerollBtn.className = 'btn ghost reroll-giveaway'; rerollBtn.dataset.id = gid; rerollBtn.textContent = 'Reroll';
              controls.appendChild(copyBtn); controls.appendChild(winnersBtn); controls.appendChild(rerollBtn);

              const row = document.createElement('div'); row.style.display = 'flex'; row.style.gap = '12px'; row.style.alignItems = 'flex-start';
              row.appendChild(leftDot); body.appendChild(titleRow); body.appendChild(meta); body.appendChild(ends);
              row.appendChild(body); row.appendChild(controls);
              card.appendChild(row);

              inner.appendChild(card);

              // attach simple handlers
              copyBtn.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(gid); try { if (typeof showToast === 'function') showToast('Copied giveaway ID', 'info'); } catch (e) { } };
              winnersBtn.onclick = async () => {
                try {
                  const out = await window.fetchGiveawayWinners(gid, { tries: 3, delayMs: 700 });
                  if (out && out.winners && out.winners.length) {
                    try {
                      const r = await fetch(`/api/giveaway-winners-resolve/${encodeURIComponent(serverId)}/${encodeURIComponent(gid)}`, { credentials: 'include' });
                      if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && Array.isArray(jb.resolved) && jb.resolved.length) { window.safeShowWinnersModal(gid, jb.resolved); return; } }
                    } catch (e) { /* ignore */ }
                    window.safeShowWinnersModal(gid, out.winners); return;
                  }
                  try { if (typeof showToast === 'function') showToast('No winners found yet. We retried contacting the bot and scanned recent activity. If you were the winner, try again in a few seconds.', 'info'); } catch (e) { console.info('No winners found yet'); }
                } catch (e) { console.warn('Failed to fetch winners', e); try { if (typeof showToast === 'function') showToast('Failed to fetch winners: ' + String(e), 'error'); } catch (e) { console.warn(e); } }
              };
              rerollBtn.onclick = async () => {
                try {
                  if (typeof window.attemptRerollAndVerify === 'function') {
                    try { if (typeof showToast === 'function') showToast('Requesting reroll and waiting for bot response‚Ä¶', 'info'); } catch (e) { }
                    const res = await window.attemptRerollAndVerify(gid, { tries: 2, pollAttempts: 8, pollDelay: 1000 });
                    if (res && res.ok) {
                      try { if (typeof showToast === 'function') showToast('Reroll succeeded', 'info'); } catch (e) { }
                      if (res.winners && res.winners.length) alert('New winners: ' + res.winners.join(', '));
                      try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                      return;
                    } else {
                      if (res && res.status && res.text) alert('Reroll request failed: ' + res.status + (res.text ? (' ‚àí ' + res.text) : ''));
                      else if (res && res.error) alert('Reroll failed: ' + (res.error || res.reason || JSON.stringify(res)));
                      else alert('Reroll failed to get a response from bot. You can try again.');
                      try { if (typeof showToast === 'function') showToast('Reroll failed', 'error'); } catch (e) { }
                    }
                  } else {
                    const r = await fetch(`/api/server-giveaway-reroll/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ giveawayId: gid }) });
                    if (r.ok) {
                      try { if (typeof showToast === 'function') showToast('Reroll requested', 'info'); } catch (e) { }
                      try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                    } else { const txt = await r.text().catch(() => null); alert('Reroll failed: ' + r.status + (txt ? (' ‚àí ' + txt) : '')); try { if (typeof showToast === 'function') showToast('Reroll failed', 'error'); } catch (e) { } }
                  }
                } catch (e) { console.warn('Failed to reroll', e); alert('Failed to reroll: ' + String(e)); }
              };

            } catch (e) { console.warn('forceRenderActivity/giveaway append failed', e); }
          });
        } else {
          const p = document.createElement('p'); p.className = 'small-muted'; p.textContent = 'No running giveaways.'; inner.appendChild(p);
        }

        // divider + recent activity header
        const divider = document.createElement('hr'); divider.style.margin = '12px 0'; inner.appendChild(divider);
        const actHeader = document.createElement('div'); actHeader.style.marginBottom = '8px'; actHeader.innerHTML = '<strong style="display:block;margin-bottom:6px">Recent Giveaway Activity</strong>'; inner.appendChild(actHeader);

        if (Array.isArray(activities) && activities.length) {
          activities.slice(0, 40).forEach(a => {
            try {
              const gid = (a.payload && (a.payload.giveawayId || a.payload.id)) || (a.config && (a.config.giveawayId || a.config.id)) || ('activity-' + (a.ts || Date.now()));
              const prize = (a.payload && a.payload.prize) || (a.config && a.config.giveaway && a.config.giveaway.prize) || (a.payload && a.payload.config && a.payload.config.giveaway && a.payload.config.giveaway.prize) || '(no prize)';
              const createdAt = a.ts ? new Date(a.ts) : null;
              let endsAt = null;
              if (a.payload) { if (a.payload.endsAt) endsAt = new Date(a.payload.endsAt); else if (a.payload.ends_at) endsAt = new Date(a.payload.ends_at); else if (a.payload.duration) endsAt = new Date((a.ts || Date.now()) + Number(a.payload.duration) * 60 * 1000); }
              if (!endsAt && a.config && a.config.giveaway && a.config.giveaway.duration) endsAt = new Date((a.ts || Date.now()) + Number(a.config.giveaway.duration) * 60 * 1000);
              const creator = a.user ? a.user.username : 'System';
              const channelText = (a.payload && a.payload.channelId) ? '#' + a.payload.channelId : '‚Äî';

              const card = document.createElement('div'); card.className = 'giveaway-item'; card.dataset.gid = gid;
              const leftDot = document.createElement('div'); leftDot.className = 'dot'; leftDot.style.background = (endsAt && Date.now() > endsAt.getTime()) ? 'var(--danger)' : '#3ad37f';
              const body = document.createElement('div'); body.style.flex = '1';
              const titleRow = document.createElement('div'); titleRow.style.display = 'flex'; titleRow.style.justifyContent = 'space-between'; titleRow.style.alignItems = 'center'; titleRow.style.gap = '8px';
              const title = document.createElement('div'); title.style.fontWeight = '700'; title.innerHTML = prize + (a.type === 'plugin_test' ? ' <span class="test-badge">Test</span>' : '') + ' <span class="small-muted" style="font-weight:400">#' + gid + '</span>';
              const created = document.createElement('div'); created.className = 'small-muted'; created.textContent = createdAt ? createdAt.toLocaleString() : '';
              titleRow.appendChild(title); titleRow.appendChild(created);
              const meta = document.createElement('div'); meta.className = 'small-muted'; meta.style.marginTop = '6px'; meta.textContent = 'By ';
              const strong = document.createElement('strong'); strong.textContent = creator; meta.appendChild(strong); meta.appendChild(document.createTextNode(' ¬∑ Channel: ' + channelText));
              const ends = document.createElement('div'); ends.className = 'small-muted'; ends.style.marginTop = '6px'; const endsText = document.createElement('span'); endsText.textContent = 'Ends: ' + (endsAt ? endsAt.toLocaleString() : '‚Äî'); ends.appendChild(endsText);

              const controls = document.createElement('div'); controls.style.display = 'flex'; controls.style.flexDirection = 'column'; controls.style.gap = '8px';
              const copyBtn = document.createElement('button'); copyBtn.className = 'btn ghost copy-id'; copyBtn.dataset.id = gid; copyBtn.textContent = 'Copy ID';
              const winnersBtn = document.createElement('button'); winnersBtn.className = 'btn ghost view-winners'; winnersBtn.dataset.id = gid; winnersBtn.textContent = 'Winners';
              const rerollBtn = document.createElement('button'); rerollBtn.className = 'btn ghost reroll-giveaway'; rerollBtn.dataset.id = gid; rerollBtn.textContent = 'Reroll';
              controls.appendChild(copyBtn); controls.appendChild(winnersBtn); controls.appendChild(rerollBtn);

              const row = document.createElement('div'); row.style.display = 'flex'; row.style.gap = '12px'; row.style.alignItems = 'flex-start';
              row.appendChild(leftDot); body.appendChild(titleRow); body.appendChild(meta); body.appendChild(ends);
              row.appendChild(body); row.appendChild(controls);
              card.appendChild(row);

              inner.appendChild(card);

              copyBtn.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(gid); try { if (typeof showToast === 'function') showToast('Copied giveaway ID', 'info'); } catch (e) { } };
              winnersBtn.onclick = async () => {
                try {
                  const out = await window.fetchGiveawayWinners(gid, { tries: 3, delayMs: 700 });
                  if (out && out.winners && out.winners.length) {
                    try { const r = await fetch(`/api/giveaway-winners-resolve/${encodeURIComponent(serverId)}/${encodeURIComponent(gid)}`, { credentials: 'include' }); if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && Array.isArray(jb.resolved) && jb.resolved.length) { window.safeShowWinnersModal(gid, jb.resolved); return; } } } catch (e) { }
                    window.safeShowWinnersModal(gid, out.winners); return;
                  }
                  try { if (typeof showToast === 'function') showToast('No winners found yet. We retried contacting the bot and scanned recent activity. If you were the winner, try again in a few seconds.', 'info'); } catch (e) { console.info('No winners found yet'); }
                } catch (e) { console.warn('Failed to fetch winners', e); try { if (typeof showToast === 'function') showToast('Failed to fetch winners: ' + String(e), 'error'); } catch (e) { console.warn(e); } }
              };
              rerollBtn.onclick = async () => {
                try {
                  if (typeof window.attemptRerollAndVerify === 'function') {
                    try { if (typeof showToast === 'function') showToast('Requesting reroll and waiting for bot response‚Ä¶', 'info'); } catch (e) { }
                    const res = await window.attemptRerollAndVerify(gid, { tries: 2, pollAttempts: 8, pollDelay: 1000 });
                    if (res && res.ok) {
                      try { if (typeof showToast === 'function') showToast('Reroll succeeded', 'info'); } catch (e) { }
                      if (res.winners && res.winners.length) alert('New winners: ' + res.winners.join(', '));
                      try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                      return;
                    } else {
                      if (res && res.status && res.text) alert('Reroll request failed: ' + res.status + (res.text ? (' ‚àí ' + res.text) : ''));
                      else if (res && res.error) alert('Reroll failed: ' + (res.error || res.reason || JSON.stringify(res)));
                      else alert('Reroll failed to get a response from bot. You can try again.');
                      try { if (typeof showToast === 'function') showToast('Reroll failed', 'error'); } catch (e) { }
                    }
                  } else {
                    const r = await fetch(`/api/server-giveaway-reroll/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ giveawayId: gid }) });
                    if (r.ok) {
                      try { if (typeof showToast === 'function') showToast('Reroll requested', 'info'); } catch (e) { }
                      try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                    } else { const txt = await r.text().catch(() => null); alert('Reroll failed: ' + r.status + (txt ? (' ‚àí ' + txt) : '')); try { if (typeof showToast === 'function') showToast('Reroll failed', 'error'); } catch (e) { } }
                  }
                } catch (e) { console.warn('Failed to reroll', e); alert('Failed to reroll: ' + String(e)); }
              };

            } catch (e) { console.warn('forceRenderActivity/activity append failed', e); }
          });
        } else {
          const p2 = document.createElement('p'); p2.className = 'small-muted'; p2.textContent = 'No recent giveaway activity.'; inner.appendChild(p2);
        }

        return true;
      } catch (e) { console.warn('forceRenderActivity failed', e); return false; }
    };

    // Helper: Try to get winners for a giveaway reliably by retrying giveaways endpoint and falling back to scanning recent activity
    if (!window.fetchGiveawayWinners) {
      window.fetchGiveawayWinners = async function (gid, opts) {
        opts = opts || {};
        const tries = typeof opts.tries === 'number' ? opts.tries : 3;
        const delayMs = typeof opts.delayMs === 'number' ? opts.delayMs : 700;
        for (let i = 0; i < tries; i++) {
          try {
            const res = await fetch(`/api/server-giveaways/${encodeURIComponent(serverId)}?giveawayId=${encodeURIComponent(gid)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e }));
            if (res && res.ok) {
              const body = await res.json().catch(() => null);
              const g = body && (body.giveaways ? (body.giveaways || []).find(x => (x.id == gid || x.giveawayId == gid)) : (body && (body.giveaway || null)));
              if (g) { const winners = g.winners || g.winner || []; if (Array.isArray(winners) && winners.length) return { source: 'giveaways', winners, giveaway: g }; }
            }
          } catch (e) { /* ignore and retry */ }
          if (i < tries - 1) await new Promise(r => setTimeout(r, delayMs));
        }
        try {
          const aRes = await fetch(`/api/server-activity/${encodeURIComponent(serverId)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e }));
          if (aRes && aRes.ok) {
            const aBody = await aRes.json().catch(() => ({ activity: [] })); const acts = aBody.activity || []; for (const a of acts) { try { if (!a) continue; const payload = a.payload || a.data || {}; const w = payload.winners || payload.winner || a.winners || null; if (w && (Array.isArray(w) ? w.length : 1)) { const winners = Array.isArray(w) ? w : [w]; return { source: 'activity', winners, activity: a }; } if ((payload.giveawayId === gid || payload.id === gid || (payload.config && payload.config.giveaway && (payload.config.giveaway.id === gid || payload.config.giveaway.giveawayId === gid))) && (payload.winners || payload.winner)) { const w2 = payload.winners || payload.winner || []; const winners = Array.isArray(w2) ? w2 : [w2]; if (winners.length) return { source: 'activity', winners, activity: a }; } } catch (e) { } }
          }
        } catch (e) { /* ignore */ }
        return null;
      };
    }

    // Helper: attempt reroll and verify by polling giveaways list for changes
    if (!window.attemptRerollAndVerify) {
      window.attemptRerollAndVerify = async function (gid, opts) {
        opts = opts || {}; const tries = typeof opts.tries === 'number' ? opts.tries : 2; const pollAttempts = typeof opts.pollAttempts === 'number' ? opts.pollAttempts : 8; const pollDelay = typeof opts.pollDelay === 'number' ? opts.pollDelay : 1000;
        for (let attempt = 0; attempt < tries; attempt++) {
          try {
            const r = await fetch(`/api/server-giveaway-reroll/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ giveawayId: gid }) });
            if (!r.ok) { const txt = await r.text().catch(() => null); return { ok: false, status: r.status, text: txt } }
            // if server accepted, poll the giveaways list to detect winners or change
            for (let p = 0; p < pollAttempts; p++) {
              try {
                const check = await fetch(`/api/server-giveaways/${encodeURIComponent(serverId)}?giveawayId=${encodeURIComponent(gid)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e }));
                if (check && check.ok) {
                  const body = await check.json().catch(() => null); const g = body && (body.giveaways ? (body.giveaways || []).find(x => (x.id == gid || x.giveawayId == gid)) : (body && (body.giveaway || null))); if (g) { const winners = g.winners || g.winner || []; if (Array.isArray(winners) && winners.length) { return { ok: true, winners, giveaway: g }; } }
                }
              } catch (e) { /* ignore */ }
              await new Promise(r => setTimeout(r, pollDelay));
            }
            // if we get here, server accepted but no winners yet
          } catch (e) { return { ok: false, error: String(e) } }
        }
        return { ok: false, reason: 'no_response' };
      };
    }

    // Add a compact server info panel (fills empty space and gives quick actions)
    const headerMeta = document.createElement('div'); headerMeta.style.display = 'flex'; headerMeta.style.gap = '18px'; headerMeta.style.marginTop = '6px';
    const infoCard = document.createElement('div'); infoCard.className = 'server-info-card';
    infoCard.innerHTML = `<strong>Server ID</strong><div class="small-muted" id="server-id">${serverId}</div>`;
    const actionsCard = document.createElement('div'); actionsCard.className = 'server-info-card';
    actionsCard.innerHTML = `<strong>Actions</strong><div style="margin-top:8px"><button id="sync-plugins" class="btn ghost">Sync plugins</button> <button id="refresh-guilds" class="btn ghost">Refresh</button></div>`;
    headerMeta.appendChild(infoCard); headerMeta.appendChild(actionsCard);
    const header = document.getElementById('server-header'); if (header) header.appendChild(headerMeta);

    // Modal markup (inserted early so it's available before handlers run)
    (function () {
      const existing = document.getElementById('plugin-modal'); if (existing) return;
      const modal = document.createElement('div'); modal.className = 'modal'; modal.id = 'plugin-modal'; modal.setAttribute('aria-hidden', 'true'); modal.innerHTML = `
      <div class="modal-content modal-config">
        <button class="modal-close" onclick="closePluginConfig()">‚úï</button>
        <div class="modal-side">
          <div style="padding:10px 12px;color:var(--muted);font-weight:700">Settings</div>
          <button class="panel-option active" data-section="config">Configuration</button>
          <button class="panel-option" data-section="theme">Theme</button>
          <button class="panel-option" data-section="help">Help</button>
        </div>
        <div class="modal-section" id="plugin-modal-body">
          <h3 id="plugin-modal-title">Plugin</h3>
          <p id="plugin-modal-desc" class="small-muted"></p>

          <div class="section-block" data-section="config">
            <div id="plugin-config-placeholder" class="small-muted">This plugin has no configurable options via the dashboard.</div>

            <!-- legacy welcome/bye blocks (kept for compatibility but hidden by default) -->
            <div class="section-block" data-section="welcome" style="margin-top:12px;display:none">
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Welcome channel ID</label>
                <input id="plugin-modal-welcome-channel" type="text" placeholder="Channel ID (optional)" />
              </div>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Welcome message</label>
                <textarea id="plugin-modal-welcome-message" rows="4" style="width:100%;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)">Welcome {user} to our server!</textarea>
                <div class="small-muted" style="margin-top:6px;font-size:0.82rem">Tips: use <code>{mention}</code> to mention the user (pings), <code>{user}</code> for username, and <code>{server}</code> for the server name.</div>
              </div>
            </div>

            <div class="section-block" data-section="bye" style="margin-top:12px;display:none">
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Bye channel ID</label>
                <input id="plugin-modal-bye-channel" type="text" placeholder="Channel ID (optional)" />
              </div>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Bye message</label>
                <textarea id="plugin-modal-bye-message" rows="4" style="width:100%;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)">Goodbye {user}!</textarea>
                <div class="small-muted" style="margin-top:6px;font-size:0.82rem">Tips: use <code>{mention}</code> to mention the user (pings), <code>{user}</code> for username, and <code>{server}</code> for the server name.</div>
              </div>
            </div>

          </div>

          <div class="section-block" data-section="theme" style="display:none">
            <div style="margin-top:6px;font-weight:700">Theme</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="theme-btn" data-theme="system" aria-pressed="false">System</button>
              <button class="theme-btn" data-theme="light" aria-pressed="false">Light</button>
              <button class="theme-btn" data-theme="dark" aria-pressed="false">Dark</button>
            </div>
            <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
              <label class="switch" style="margin:0"><input id="plugin-modal-theme-apply-server" type="checkbox" /><span class="switch-ui"></span><span class="switch-label">Apply to this server</span></label>
              <label class="switch" style="margin:0"><input id="plugin-modal-theme-apply-global" type="checkbox" /><span class="switch-ui"></span><span class="switch-label">Save as global override</span></label>
            </div>
            <div id="theme-preview" style="margin-top:12px;padding:12px;border-radius:10px;border:1px solid var(--border);background:var(--card);display:flex;align-items:center;gap:12px">
              <div id="theme-preview-sample" style="flex:1"><strong>Preview</strong><div class="small-muted">Text, controls and modal look will update</div></div>
            </div>
          </div>

          <div class="section-block" data-section="help" style="display:none;margin-top:12px">
            <p class="small-muted">No additional help available for this plugin.</p>
          </div>

          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
            <button class="btn ghost" onclick="closePluginConfig()">Cancel</button>
            <button id="plugin-modal-reset" class="btn ghost">Reset</button>
            <button id="plugin-modal-test" class="btn ghost">Send test</button>
            <button id="plugin-modal-save" class="btn primary">Save</button>
          </div>
        </div>
      </div>`;
      document.body.appendChild(modal);

      // Theme controls for this modal: apply saved theme and wire buttons
      (function () {
        function resolveStoredTheme() {
          try {
            const srv = localStorage.getItem('ng_theme_' + serverId);
            if (srv) { const obj = JSON.parse(srv); return obj && obj.bgMode ? obj.bgMode : 'system'; }
            const g = localStorage.getItem('ng_theme_global');
            if (g) { const obj2 = JSON.parse(g); return obj2 && obj2.bgMode ? obj2.bgMode : 'system'; }
            return localStorage.getItem('ng_theme') || 'system';
          } catch (e) { return localStorage.getItem('ng_theme') || 'system'; }
        }
        function updateModalTheme(theme) {
          const isLight = (theme === 'light') || (theme === 'system' && window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches);
          modal.classList.toggle('light-theme', isLight);
          const btns = modal.querySelectorAll('.theme-btn');
          btns.forEach(b => b.classList.toggle('active', b.dataset.theme === theme));
          const preview = modal.querySelector('#theme-preview-sample');
          if (preview) preview.innerHTML = '<strong>Preview</strong><div class="small-muted">Theme: ' + theme + '</div>';
          if (theme === 'light') document.documentElement.classList.add('theme-light');
          else if (theme === 'dark') document.documentElement.classList.remove('theme-light');
          else { const isSysLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches; if (isSysLight) document.documentElement.classList.add('theme-light'); else document.documentElement.classList.remove('theme-light'); }
        }
        modal.querySelectorAll('.theme-btn').forEach(b => b.addEventListener('click', () => {
          const t = b.dataset.theme;
          const applyServer = !!modal.querySelector('#plugin-modal-theme-apply-server').checked;
          const applyGlobal = !!modal.querySelector('#plugin-modal-theme-apply-global').checked;
          try {
            if (applyServer) { localStorage.setItem('ng_theme_' + serverId, JSON.stringify({ bgMode: t })); }
            if (applyGlobal) { localStorage.setItem('ng_theme_global', JSON.stringify({ bgMode: t })); }
            if (!applyServer && !applyGlobal) { localStorage.setItem('ng_theme', t); }
            updateModalTheme(t);
            try { if (typeof showToast === 'function') showToast('Applied theme: ' + t, 'info', 1200); } catch (e) { }
          } catch (e) { console.warn('Failed to save theme', e); }
        }));
        updateModalTheme(resolveStoredTheme());
        window.addEventListener('storage', () => { updateModalTheme(resolveStoredTheme()); });
      })();

      // Wire side panel buttons to switch modal sections (config / theme / help)
      (function () {
        const btns = modal.querySelectorAll('.panel-option');
        const sections = modal.querySelectorAll('.section-block');
        function setActive(s) {
          sections.forEach(sb => sb.style.display = (sb.dataset.section === s) ? 'block' : 'none');
          btns.forEach(b => b.classList.toggle('active', b.dataset.section === s));
        }
        btns.forEach(b => b.addEventListener('click', () => { setActive(b.dataset.section); }));
        // default to config
        setActive('config');
      })();



      // close when clicking outside content
      modal.addEventListener('click', (e) => { if (e.target === modal) { if (typeof window.closePluginConfig === 'function') window.closePluginConfig(); } });
      // close on Escape
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { const m = document.getElementById('plugin-modal'); if (m && m.getAttribute('aria-hidden') === 'false') { if (typeof window.closePluginConfig === 'function') window.closePluginConfig(); } } });

      // create a reusable custom confirm modal (replaces native confirm())
      (function () {
        if (document.getElementById('confirm-modal')) return;
        const c = document.createElement('div'); c.id = 'confirm-modal'; c.className = 'modal'; c.setAttribute('aria-hidden', 'true');
        c.innerHTML = `
        <div class="modal-content confirm-modal">
          <div style="display:flex;gap:12px;align-items:flex-start">
            <div class="confirm-icon" aria-hidden="true">‚ö†Ô∏è</div>
            <div style="flex:1;min-width:0">
              <h3 id="confirm-modal-title">Reset</h3>
              <p id="confirm-modal-msg" class="small-muted">Are you sure you want to reset this setting to defaults?</p>
            </div>
          </div>
          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:14px">
            <button id="confirm-cancel" class="btn ghost">Cancel</button>
            <button id="confirm-ok" class="btn danger">Reset</button>
          </div>
        </div>`;
        document.body.appendChild(c);

        const okBtn = c.querySelector('#confirm-ok');
        const cancelBtn = c.querySelector('#confirm-cancel');
        let _confirmResolve = null;
        function openConfirm(msg, title) {
          c.setAttribute('aria-hidden', 'false'); c.style.display = 'flex';
          const t = document.getElementById('confirm-modal-title'); if (t) t.textContent = title || 'Reset';
          const m = document.getElementById('confirm-modal-msg'); if (m) m.textContent = msg || '';
          // focus primary
          setTimeout(() => { if (okBtn) okBtn.focus(); }, 50);
          return new Promise((resolve) => { _confirmResolve = resolve; });
        }
        function closeConfirm(val) {
          c.setAttribute('aria-hidden', 'true'); setTimeout(() => { c.style.display = 'none'; }, 200);
          if (_confirmResolve) { _confirmResolve(Boolean(val)); _confirmResolve = null; }
        }
        okBtn.addEventListener('click', () => closeConfirm(true));
        cancelBtn.addEventListener('click', () => closeConfirm(false));
        c.addEventListener('click', (e) => { if (e.target === c) closeConfirm(false); });
        // keyboard: Enter to confirm, Escape to cancel
        c.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeConfirm(false); if (e.key === 'Enter') closeConfirm(true); });
        window.showConfirm = openConfirm; // global helper
      })();

      // Welcome modal (separate from generic modal)
      (function () {
        if (document.getElementById('plugin-modal-welcome')) return;
        const modal = document.createElement('div'); modal.id = 'plugin-modal-welcome'; modal.className = 'modal'; modal.setAttribute('aria-hidden', 'true');
        modal.innerHTML = `
        <div class="modal-content modal-config">
          <button class="modal-close" onclick="closeWelcomeConfig()">‚úï</button>
          <div class="modal-side">
            <div style="padding:10px 12px;color:var(--muted);font-weight:700">Welcome</div>
            <button class="panel-option active" data-section="welcome">Welcome message</button>
            <button class="panel-option" data-section="bye">Bye message</button>
          </div>
          <div class="modal-section" style="min-width:0">
            <h3>Welcome Plugin Settings</h3>
            <p class="small-muted">Configure welcome and goodbye messages for this server.</p>

            <div class="section-block" data-section="welcome">
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Welcome channel ID</label>
                <input id="welcome-modal-welcome-channel" type="text" placeholder="Channel ID (optional)" />
              </div>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Welcome message</label>
                <textarea id="welcome-modal-welcome-message" rows="4" style="width:100%;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)"></textarea>
              </div>
            </div>

            <div class="section-block" data-section="bye" style="display:none">
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Bye channel ID</label>
                <input id="welcome-modal-bye-channel" type="text" placeholder="Channel ID (optional)" />
              </div>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Bye message</label>
                <textarea id="welcome-modal-bye-message" rows="4" style="width:100%;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)"></textarea>
              </div>
            </div>

            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
              <button class="btn ghost" onclick="closeWelcomeConfig()">Cancel</button>
              <button id="welcome-modal-reset" class="btn ghost">Reset</button>
              <button id="welcome-modal-test" class="btn ghost">Send test</button>
              <button id="welcome-modal-save" class="btn primary">Save</button>
            </div>
          </div>
        </div>`;
        document.body.appendChild(modal);

        // Theme controls for this modal: apply saved theme and wire buttons
        (function () {
          const stored = localStorage.getItem('ng_theme') || localStorage.getItem('ng_theme_global') || 'system';
          function updateModalTheme(theme) {
            const isLight = (theme === 'light') || (theme === 'system' && window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches);
            modal.classList.toggle('light-theme', isLight);
            const btns = modal.querySelectorAll('.theme-btn');
            btns.forEach(b => b.classList.toggle('active', b.dataset.theme === theme));
          }
          modal.querySelectorAll('.theme-btn').forEach(b => b.addEventListener('click', () => { const t = b.dataset.theme; localStorage.setItem('ng_theme', t); updateModalTheme(t); }));
          updateModalTheme(stored);
          const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)');
          if (mq && mq.addEventListener) { mq.addEventListener('change', () => { if ((localStorage.getItem('ng_theme') || 'system') === 'system') updateModalTheme('system'); }); }
          else if (mq && mq.addListener) { mq.addListener(() => { if ((localStorage.getItem('ng_theme') || 'system') === 'system') updateModalTheme('system'); }); }

        })();

        // simple helper functions wired below by openWelcomeConfig
      })();

      // Giveaway modal (separate)
      (function () {
        if (document.getElementById('plugin-modal-giveaway')) return;
        const modal = document.createElement('div'); modal.id = 'plugin-modal-giveaway'; modal.className = 'modal'; modal.setAttribute('aria-hidden', 'true');
        modal.innerHTML = `
        <div class="modal-content modal-config">
          <button class="modal-close" onclick="closeGiveawayConfig()">‚úï</button>
          <div class="modal-side">
            <div style="padding:10px 12px;color:var(--muted);font-weight:700">Giveaway</div>

            <button class="panel-option active" data-section="defaults" onclick="(function(){ var s='defaults'; var m=document.getElementById('plugin-modal-giveaway'); if (m){ m.querySelectorAll('.section-block').forEach(function(sb){ sb.style.display = (sb.dataset.section === s) ? 'block':'none'; }); m.querySelectorAll('.panel-option').forEach(function(b){ b.classList.toggle('active', b.dataset.section === s); }); var v; m.querySelectorAll('.section-block').forEach(function(sb){ if (sb.dataset.section === s) v = sb; }); if (v){ var f = v.querySelector('input,textarea,button'); if (f) f.focus(); } try{ if (typeof showToast === 'function') showToast('Opened '+s,'info'); }catch(e){} console.log('inline switched to '+s); } })()">Defaults</button>
            <button class="panel-option" data-section="activity" onclick="(function(){ var s='activity'; var m=document.getElementById('plugin-modal-giveaway'); if (m){ m.querySelectorAll('.section-block').forEach(function(sb){ sb.style.display = (sb.dataset.section === s) ? 'block':'none'; }); m.querySelectorAll('.panel-option').forEach(function(b){ b.classList.toggle('active', b.dataset.section === s); }); var v; m.querySelectorAll('.section-block').forEach(function(sb){ if (sb.dataset.section === s) v = sb; }); if (v){ var f = v.querySelector('input,textarea,button'); if (f) f.focus(); } try{ if (typeof showToast === 'function') showToast('Opened '+s,'info'); }catch(e){} console.log('inline switched to '+s); } })()">Activity</button>
            <button class="panel-option" data-section="reroll" onclick="(function(){ var s='reroll'; var m=document.getElementById('plugin-modal-giveaway'); if (m){ m.querySelectorAll('.section-block').forEach(function(sb){ sb.style.display = (sb.dataset.section === s) ? 'block':'none'; }); m.querySelectorAll('.panel-option').forEach(function(b){ b.classList.toggle('active', b.dataset.section === s); }); var v; m.querySelectorAll('.section-block').forEach(function(sb){ if (sb.dataset.section === s) v = sb; }); if (v){ var f = v.querySelector('input,textarea,button'); if (f) f.focus(); } try{ if (typeof showToast === 'function') showToast('Opened '+s,'info'); }catch(e){} console.log('inline switched to '+s); } })()">Reroll</button>
          </div>
          <div class="modal-section" style="min-width:0">
            <div style="display:flex;align-items:center;gap:12px;justify-content:space-between">
              <div>
                <h3 style="margin:0">Giveaway Defaults</h3>
                <p class="small-muted" style="margin:4px 0 0">Set default giveaway settings for this server.</p>
              </div>

            </div>

            <div class="section-block" data-section="defaults">
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Default duration</label>
                <div style="display:flex;gap:8px;align-items:center">
                  <div class="number-box" style="display:flex;align-items:center">
                    <button type="button" class="num-btn num-decr-min" aria-label="Decrease minutes">‚àí</button>
                    <input id="giveaway-modal-duration-min" type="number" min="0" placeholder="Minutes" value="60" />
                    <button type="button" class="num-btn num-incr-min" aria-label="Increase minutes">+</button>
                  </div>
                  <div class="number-box" style="display:flex;align-items:center">
                    <button type="button" class="num-btn num-decr-sec" aria-label="Decrease seconds">‚àí</button>
                    <input id="giveaway-modal-duration-sec" type="number" min="0" max="59" placeholder="Seconds" value="0" />
                    <button type="button" class="num-btn num-incr-sec" aria-label="Increase seconds">+</button>
                  </div>
                  <div class="small-muted" style="font-size:0.9rem">minutes / seconds</div>
                </div>
              </div>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Announcement channel ID</label>
                <input id="giveaway-modal-channel" type="text" placeholder="Channel ID (optional)" />
              </div>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Default prize text</label>
                <input id="giveaway-modal-prize" type="text" placeholder="e.g., Nitro subscription" />
              </div>
              <div style="margin-top:12px;display:flex;align-items:center;gap:12px">
                <div class="switch-giveaway-mention" style="display:flex;align-items:center;gap:12px;margin:0">
                  <label class="switch" style="margin:0">
                    <input id="giveaway-modal-mention" type="checkbox" checked />
                    <span class="switch-ui"></span>
                  </label>
                  <span class="switch-label" style="cursor:default;margin-left:6px">Mention winners by default</span>
                </div>
              </div>
            </div>

            <div class="section-block" data-section="activity" style="display:none">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;margin-bottom:8px">
                <h4 style="margin:0">Activity</h4>
                <button id="giveaway-activity-refresh" class="btn ghost" title="Refresh Activity" style="padding:6px 8px;font-size:0.85rem;line-height:1">‚Üª</button>
              </div>
              <div id="giveaway-activity-list" class="card preview" style="min-height:120px;padding:12px;max-height:360px;overflow:auto">
                <div id="giveaway-activity-panel" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:12px">
                  <div style="display:flex;gap:10px;align-items:center">
                  <div id="giveaway-activity-status" class="small-muted">Activity (live)</div>
                  <div id="giveaway-activity-token" class="small-muted" style="font-weight:700;color:var(--accent);margin-left:6px">&nbsp;</div>
                </div>
                  <div style="display:flex;gap:8px"><div class="small-muted" style="font-size:0.85rem">Auto-refresh: <span id="giveaway-activity-interval">15s</span></div></div>
                </div>
                <div id="giveaway-activity-inner"> <p class="small-muted">Loading giveaway activity‚Ä¶</p> </div>
              </div>
            </div>



            <div class="section-block" data-section="reroll" style="display:none">
              <h4 style="margin-top:8px;margin-bottom:8px">Reroll Giveaway</h4>
              <div style="margin-top:12px">
                <label style="display:block;margin-bottom:6px">Giveaway ID</label>
                <input id="giveaway-reroll-id" type="text" placeholder="Giveaway ID to reroll" />
                <div style="margin-top:8px"><button id="giveaway-reroll-btn" class="btn primary" onclick="(async function(){ const input=document.getElementById('giveaway-reroll-id'); const result=document.getElementById('giveaway-reroll-result'); if (result) result.textContent=''; const gid = input ? input.value.trim() : ''; if (!gid){ if (result) result.textContent='Enter a giveaway ID to reroll'; return; } try{ const r = await fetch('/api/server-giveaway-reroll/' + encodeURIComponent(serverId), { method: 'POST', credentials: 'include', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ giveawayId: gid }) }); if (r.ok){ const jb = await r.json(); if (result) result.textContent = jb && jb.result ? String(jb.result) : 'Reroll requested'; try{ if (typeof showToast === 'function') showToast('Reroll requested','info'); }catch(e){} } else if (r.status === 401){ if (result) result.textContent = 'Not authenticated'; try{ if (typeof showToast === 'function') showToast('Not authenticated','error'); }catch(e){} } else { let body = null; try{ body = await r.json(); }catch(e){ body = { text: await r.text().catch(()=>null) }; } const reason = (body && (body.details && (body.details.suggestion || body.details.error || body.details.message))) || body && (body.error || body.message) || body && body.text || 'Unknown'; if (result) result.textContent = 'Failed: ' + r.status + ' ' + reason; try{ if (typeof showToast === 'function') showToast('Reroll failed: ' + reason,'error'); }catch(e){} } }catch(e){ if (result) result.textContent = 'Reroll request failed'; try{ if (typeof showToast === 'function') showToast('Reroll request failed','error'); }catch(e){} } })()">Reroll</button></div>
                <div id="giveaway-reroll-result" class="small-muted" style="margin-top:8px"></div>
              </div>
            </div>

            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
              <button class="btn ghost" onclick="closeGiveawayConfig()">Cancel</button>
              <button id="giveaway-modal-reset" class="btn ghost">Reset</button>
              <button id="giveaway-modal-test" class="btn ghost" onclick="(window.sendGiveawayTest || (()=>{}))()">Send test</button>
              <button id="giveaway-modal-save" class="btn primary" onclick="(window.saveGiveawayConfig || (()=>{}))()">Save</button>
            </div>
            <div id="giveaway-modal-status" class="small-muted" style="margin-top:8px"></div>
          </div>
        </div>`;
        document.body.appendChild(modal);

        // Change Save -> Create when Defaults is active
        (function () {
          const m = document.getElementById('plugin-modal-giveaway');
          if (m) {
            const saveBtn = m.querySelector('#giveaway-modal-save');
            function setSaveFor(section) { if (!saveBtn) return; saveBtn.textContent = (section === 'defaults') ? 'Create' : 'Save'; }
            // initialize based on current active panel (defaults by default)
            const active = m.querySelector('.panel-option.active');
            setSaveFor(active ? active.dataset.section : 'defaults');
            // wire to update after the inline handlers run
            m.querySelectorAll('.panel-option').forEach(b => b.addEventListener('click', () => { setTimeout(() => setSaveFor(b.dataset.section), 0); }));
          }
        })();

        // Theme controls for this modal: apply saved theme and wire buttons
        (function () {
          const stored = localStorage.getItem('ng_theme') || localStorage.getItem('ng_theme_global') || 'system';
          function updateModalTheme(theme) {
            const isLight = (theme === 'light') || (theme === 'system' && window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches);
            modal.classList.toggle('light-theme', isLight);
            const btns = modal.querySelectorAll('.theme-btn');
            btns.forEach(b => b.classList.toggle('active', b.dataset.theme === theme));
          }
          modal.querySelectorAll('.theme-btn').forEach(b => b.addEventListener('click', () => { const t = b.dataset.theme; localStorage.setItem('ng_theme', t); updateModalTheme(t); }));
          updateModalTheme(stored);
          const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)');
          if (mq && mq.addEventListener) { mq.addEventListener('change', () => { if ((localStorage.getItem('ng_theme') || 'system') === 'system') updateModalTheme('system'); }); }
          else if (mq && mq.addListener) { mq.addListener(() => { if ((localStorage.getItem('ng_theme') || 'system') === 'system') updateModalTheme('system'); }); }

        })();

        // Make certain switches only toggle when the visual switch is clicked
        // Prevents toggling when clicking on the descriptive label text
        (function () {
          const m = modal;
          if (!m) return;
          // Use capture to intercept before the label default toggles the checkbox
          m.addEventListener('click', function (ev) {
            const sw = ev.target.closest('.switch');
            if (!sw) return;
            const input = sw.querySelector('input[type="checkbox"]');
            if (!input) return;
            // If the user clicked the visual switch or the checkbox itself, allow it
            if (ev.target === input || ev.target.closest('.switch-ui')) return;
            // Otherwise prevent the label click from toggling the checkbox
            ev.preventDefault();
            ev.stopPropagation();
          }, true);
        })();

        // ensure +/- buttons work even if modal wiring hasn't run yet (minutes + seconds)
        (function () {
          const m = document.getElementById('plugin-modal-giveaway');
          if (!m) return;
          const bindButtons = () => {
            const minInput = m.querySelector('#giveaway-modal-duration-min');
            const secInput = m.querySelector('#giveaway-modal-duration-sec');
            // minutes
            m.querySelectorAll('.num-decr-min').forEach(b => b.addEventListener('click', (ev) => { ev.preventDefault(); try { const n = Math.max(0, Number(minInput.value) || 0); minInput.value = String(Math.max(0, n - 1)); } catch (e) { console.warn('decr-min click error', e); } }));
            m.querySelectorAll('.num-incr-min').forEach(b => b.addEventListener('click', (ev) => { ev.preventDefault(); try { const n = Number(minInput.value) || 0; minInput.value = String(n + 1); } catch (e) { console.warn('incr-min click error', e); } }));
            // seconds (wrap 0-59)
            m.querySelectorAll('.num-decr-sec').forEach(b => b.addEventListener('click', (ev) => { ev.preventDefault(); try { let n = Number(secInput.value) || 0; n = Math.max(0, n - 1); secInput.value = String(n); } catch (e) { console.warn('decr-sec click error', e); } }));
            m.querySelectorAll('.num-incr-sec').forEach(b => b.addEventListener('click', (ev) => { ev.preventDefault(); try { let n = Number(secInput.value) || 0; n = Math.min(59, n + 1); secInput.value = String(n); } catch (e) { console.warn('incr-sec click error', e); } }));
          };
          bindButtons();
          const obs = new MutationObserver(() => bindButtons()); obs.observe(m, { childList: true, subtree: true });
        })();

        // simple helper functions wired below by openGiveawayConfig
      })();
    })();

    // Ensure Activity refresh button triggers a refresh reliably (works even if element is re-rendered)
    (function () {
      document.addEventListener('click', function (ev) {
        try {
          const b = ev.target.closest && ev.target.closest('#giveaway-activity-refresh');
          if (!b) return;
          ev.preventDefault();
          b.disabled = true;
          const doRefresh = (typeof window.tryRefreshGiveawayActivity === 'function') ? window.tryRefreshGiveawayActivity : (typeof window.refreshGiveawayActivity === 'function' ? window.refreshGiveawayActivity : null);
          if (!doRefresh) { b.disabled = false; return; }
          // call and ensure button is re-enabled after a short delay
          Promise.resolve().then(() => doRefresh()).finally(() => setTimeout(() => { try { b.disabled = false; } catch (e) { } }, 600));
        } catch (e) { console.warn('Activity refresh click handler error', e); }
      }, false);
    })();

    // Apply saved theme on load (system mode respects OS) so modals and page reflect it
    (function () {

      function resolveStoredTheme() {
        try {
          const srv = localStorage.getItem('ng_theme_' + serverId);
          if (srv) { try { const so = JSON.parse(srv); if (so && so.bgMode) return so.bgMode; } catch (e) { } }
          const g = localStorage.getItem('ng_theme_global');
          if (g) { try { const go = JSON.parse(g); if (go && go.bgMode) return go.bgMode; } catch (e) { } }
          const v = localStorage.getItem('ng_theme');
          return v || 'system';
        } catch (e) { return localStorage.getItem('ng_theme') || 'system'; }
      }
      function applySys(theme) {
        if (theme === 'light') document.documentElement.classList.add('theme-light');
        else if (theme === 'dark') document.documentElement.classList.remove('theme-light');
        else { const isLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches; if (isLight) document.documentElement.classList.add('theme-light'); else document.documentElement.classList.remove('theme-light'); }
      }
      applySys(resolveStoredTheme());
      const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)');
      if (mq && mq.addEventListener) { mq.addEventListener('change', () => { if ((localStorage.getItem('ng_theme') || localStorage.getItem('ng_theme_global') || 'system') === 'system') applySys('system'); }); }
      else if (mq && mq.addListener) { mq.addListener(() => { if ((localStorage.getItem('ng_theme') || localStorage.getItem('ng_theme_global') || 'system') === 'system') applySys('system'); }); }
      // React to storage changes from other tabs (handle JSON global/server keys)
      window.addEventListener('storage', () => { applySys(resolveStoredTheme()); });
    })();

    // load plugin state: prefer server-side if authenticated, otherwise localStorage
    let serverAuth = false;
    let cachedPluginState = {};
    function getPluginKey(id) { return `ng_plugins_${serverId}`; }

    async function detectServerAuth() {
      try {
        const res = await fetch('/api/me', { credentials: 'include' });
        if (res.ok) { const data = await res.json(); if (data?.user) { serverAuth = true; document.querySelector('.section-lead').textContent = 'Enable or configure plugins for this server. Changes are saved to the server.'; return; } }
      } catch (e) { /* ignore */ }
      serverAuth = false;
    }
    async function loadPluginState(forceRefresh = false) {
      let serverState = null;
      if (serverAuth) {
        try {
          const res = await fetch(`/api/server-plugins/${encodeURIComponent(serverId)}`, { credentials: 'include' });
          if (res.ok) {
            const body = await res.json();
            serverState = body.state || null;
          }
          if (res.status === 401) { serverAuth = false; }
        } catch (e) { }
      }

      // Load from local storage
      let localState = {};
      try { const raw = localStorage.getItem(getPluginKey(serverId)); if (raw) localState = JSON.parse(raw) || {}; } catch (e) { }

      // Merge Strategy: Prefer server if non-empty, otherwise fallback to local cache
      if (serverState && Object.keys(serverState).length > 0) {
        cachedPluginState = serverState;
        localStorage.setItem(getPluginKey(serverId), JSON.stringify(serverState));
      } else if (Object.keys(localState).length > 0) {
        // We have local data but either server fetch failed or server returned empty (likely Vercel file loss)
        cachedPluginState = localState;
        // If server was empty but we have local, don't overwrite server yet, let the next toggle handle it
      } else {
        cachedPluginState = serverState || {};
      }
      return cachedPluginState;
    }
    async function savePluginState(state) {
      // Update local cache first
      cachedPluginState = state;
      localStorage.setItem(getPluginKey(serverId), JSON.stringify(state));

      if (serverAuth) {
        try {
          const res = await fetch(`/api/server-plugins/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ state }) });
          if (res.ok) { showToast('Saved to server', 'info'); return; }
          if (res.status === 401) { serverAuth = false; }
        } catch (e) { showToast('Failed to save to server', 'error'); }
      } else {
        showToast('Saved locally', 'info');
      }
    }

    // Wire up header actions
    document.addEventListener('click', (ev) => {
      if (ev.target && ev.target.id === 'sync-plugins') {
        // attempt to re-fetch from server and re-render
        (async () => { showToast('Syncing plugin state‚Ä¶', 'info'); await detectServerAuth(); await renderPlugins(); showToast('Sync complete', 'info'); })();
      }
      if (ev.target && ev.target.id === 'refresh-guilds') {
        window.location.reload();
      }
      if (ev.target && ev.target.id === 'refresh-members') {
        (async () => { showToast('Refreshing members‚Ä¶', 'info'); await loadMembers(); showToast('Members refreshed', 'info'); })();
      }
    });

    function showToast(message, type = 'info', duration = 1400) {
      // Delegate to the global implementation in script.js if available
      if (window.showToast && window.showToast !== showToast && typeof window.showToast === 'function') {
        return window.showToast(message, type, duration);
      }
      // Fallback minimal toast (shouldn't be reached if script.js is loaded)
      let t = document.querySelector('.toast');
      if (!t) { t = document.createElement('div'); t.className = 'toast'; t.setAttribute('role', 'status'); t.innerHTML = '<div class="toast-icon" aria-hidden="true"></div><div class="toast-text"></div><button class="toast-close" aria-label="Close">‚úï</button>'; document.body.appendChild(t); t.querySelector('.toast-close').addEventListener('click', () => { t.classList.remove('show'); clearTimeout(t._hide); }); }
      try { t.style.zIndex = 20000; } catch (e) { }
      const txt = t.querySelector('.toast-text'); if (txt) txt.textContent = message; t.classList.remove('toast-error', 'toast-info'); t.classList.add(type === 'error' ? 'toast-error' : 'toast-info'); t.classList.add('show'); clearTimeout(t._hide); t._hide = setTimeout(() => t.classList.remove('show'), duration);
    }

    async function renderPlugins() {
      const grid = document.getElementById('plugin-grid');
      grid.innerHTML = '';
      const state = await loadPluginState();
      PLUGINS.forEach(p => {
        const pid = p.id || p.title?.toLowerCase();
        const enabled = (pid in state) ? !!state[pid] : true; // default to enabled
        const div = document.createElement('div'); div.className = 'plugin-card';
        div.innerHTML = `
        <span class="plugin-card-status ${enabled ? 'enabled' : 'disabled'}" title="Status: ${enabled ? 'Enabled' : 'Disabled'}"></span>
        <div style="display:flex;gap:12px;align-items:center;width:100%">
          <div class="plugin-icon" aria-hidden="true">${p.icon || '‚ùî'}</div>
          <div style="flex:1">
            <h4 style="margin:0">${p.title || p.titleNice || pid}</h4>
            <p style="margin:6px 0 0">${p.description}</p>
            <div class="small-muted" style="margin-top:8px;font-size:0.85rem">Status: <strong>${enabled ? 'Enabled' : 'Disabled'}</strong></div>
          </div>
        </div>
        <div class="plugin-actions">
          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <button class="btn ${enabled ? 'ghost' : 'primary'} toggle-btn" data-id="${pid}">${enabled ? 'Disable' : 'Enable'}</button>
            <button class="btn ghost configure-btn" data-id="${pid}">Configure</button>
          </div>
        </div>
      `;
        grid.appendChild(div);
      });

      // attach handlers
      grid.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.dataset.id;
          btn.disabled = true;
          const originalText = btn.textContent;
          btn.textContent = '...';

          try {
            // Use local cache for immediate toggle calculation
            const current = (id in cachedPluginState) ? !!cachedPluginState[id] : true;
            const targetEnabled = !current;

            const plugin = PLUGINS.find(x => x.id === id);

            if (serverAuth) {
              const res = await fetch(`/api/server-plugins/${encodeURIComponent(serverId)}`, {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pluginId: id, enabled: targetEnabled })
              });

              if (res.ok) {
                const body = await res.json();
                if (body && body.state) cachedPluginState = body.state;
                showToast(`${targetEnabled ? 'Enabled' : 'Disabled'} plugin: ${plugin ? (plugin.title || plugin.titleNice) : id}`, 'info');
              } else if (res.status === 401) {
                serverAuth = false;
                showToast('Not authenticated; changes will be saved locally', 'error');
              } else {
                showToast('Failed to save to server; change saved locally', 'error');
              }
            }

            // Sync cache and local storage
            cachedPluginState[id] = targetEnabled;
            localStorage.setItem(getPluginKey(serverId), JSON.stringify(cachedPluginState));

            if (!serverAuth) {
              showToast(`${targetEnabled ? 'Enabled' : 'Disabled'} plugin: ${plugin ? (plugin.title || plugin.titleNice) : id}`, 'info');
            }

            // Update UI
            btn.classList.toggle('primary', !targetEnabled);
            btn.classList.toggle('ghost', targetEnabled);
            btn.textContent = targetEnabled ? 'Disable' : 'Enable';

            const card = btn.closest('.plugin-card');
            if (card) {
              const dot = card.querySelector('.plugin-card-status');
              if (dot) {
                dot.classList.toggle('enabled', targetEnabled);
                dot.classList.toggle('disabled', !targetEnabled);
                dot.title = targetEnabled ? 'Status: Enabled' : 'Status: Disabled';
              }
              const statusText = card.querySelector('strong');
              if (statusText) statusText.textContent = targetEnabled ? 'Enabled' : 'Disabled';
            }
          } catch (e) {
            console.error('Plugin toggle failed', e);
            showToast('An error occurred while toggling the plugin', 'error');
            btn.textContent = originalText;
          } finally {
            btn.disabled = false;
          }
        });
      });

      // configure button handlers
      grid.querySelectorAll('.configure-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.dataset.id;
          openPluginConfig(id);
        });
      });

      // plugin configuration modal
      // expose as globals so modal inline handlers can access them reliably
      // Dispatcher to open plugin-specific modals
      window.openPluginConfig = function (id) {
        if (id === 'welcome') return (typeof window.openWelcomeConfig === 'function') ? window.openWelcomeConfig(id) : showToast('Welcome modal not ready', 'error');
        if (id === 'giveaway' || id === 'giveaways') {
          if (typeof window.openGiveawayConfig === 'function') return window.openGiveawayConfig(id);
          const gm = document.getElementById('plugin-modal-giveaway'); if (gm) { gm.setAttribute('aria-hidden', 'false'); gm.style.display = 'flex'; syncAutofillInModal(gm); return; }
          return showToast('Giveaway modal not ready', 'error');
        }
        // fallback: open generic modal
        const modal = document.getElementById('plugin-modal');
        const title = document.getElementById('plugin-modal-title');
        const desc = document.getElementById('plugin-modal-desc');
        const plugin = PLUGINS.find(p => p.id === id || (p.title && p.title.toLowerCase() === id));
        if (title) title.textContent = (plugin && (plugin.title || plugin.titleNice)) ? (plugin.title || plugin.titleNice) : id.charAt(0).toUpperCase() + id.slice(1);
        if (desc) desc.textContent = plugin ? plugin.description : 'This plugin has no configurable options via the dashboard.';
        if (modal) { syncModalTheme(modal); modal.setAttribute('aria-hidden', 'false'); modal.style.display = 'flex'; syncAutofillInModal(modal); }
      };

      // Welcome plugin modal handlers
      window.openWelcomeConfig = async function (id) {
        const modal = document.getElementById('plugin-modal-welcome'); if (!modal) return showToast('Modal not available', 'error');
        const wCh = document.getElementById('welcome-modal-welcome-channel');
        const wMsg = document.getElementById('welcome-modal-welcome-message');
        const bCh = document.getElementById('welcome-modal-bye-channel');
        const bMsg = document.getElementById('welcome-modal-bye-message');
        const saveBtn = document.getElementById('welcome-modal-save');
        const resetBtn = document.getElementById('welcome-modal-reset');

        // load saved settings (server or local)
        let obj = { welcome: { channel: '', message: 'Welcome {user} to our server!' }, bye: { channel: '', message: 'Goodbye {user}!' } };
        try {
          if (serverAuth) {
            const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { credentials: 'include' });
            if (res.ok) { const body = await res.json(); if (body && body.config) { const cfg = body.config[id] || body.config; if (cfg.welcome || cfg.bye) { obj.welcome = Object.assign({}, obj.welcome, cfg.welcome || {}); obj.bye = Object.assign({}, obj.bye, cfg.bye || {}); } else { obj = Object.assign({}, obj, cfg); } } }
            if (res.status === 401) serverAuth = false;
          } else {
            const raw = localStorage.getItem(`ng_plugin_config_${serverId}_${id}`); if (raw) obj = JSON.parse(raw);
          }
        } catch (e) { console.warn('Failed to load welcome config', e); }

        wCh.value = (obj.welcome && obj.welcome.channel) || '';
        wMsg.value = (obj.welcome && obj.welcome.message) || 'Welcome {user} to our server!';
        bCh.value = (obj.bye && obj.bye.channel) || '';
        bMsg.value = (obj.bye && obj.bye.message) || 'Goodbye {user}!';

        // setup side buttons (Welcome/Bye) inside modal
        const sideButtons = modal.querySelectorAll('.panel-option') || [];
        function setActiveSectionWelcome(s) {
          modal.querySelectorAll('.section-block').forEach(sb => { sb.style.display = (sb.dataset.section === s) ? 'block' : 'none'; });
          sideButtons.forEach(b => b.classList.toggle('active', b.dataset.section === s));
        }
        sideButtons.forEach(b => b.onclick = () => setActiveSectionWelcome(b.dataset.section));
        // default
        setActiveSectionWelcome('welcome');

        syncModalTheme(modal); modal.setAttribute('aria-hidden', 'false'); modal.style.display = 'flex'; syncAutofillInModal(modal);

        if (saveBtn) {
          saveBtn.onclick = async () => {
            const data = { welcome: { channel: (wCh ? wCh.value.trim() : ''), message: (wMsg ? wMsg.value.trim() : '') }, bye: { channel: (bCh ? bCh.value.trim() : ''), message: (bMsg ? bMsg.value.trim() : '') } };
            if (serverAuth) { try { const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: id, config: data }) }); if (res.ok) { showToast('Saved settings to server', 'info'); closeWelcomeConfig(); return; } if (res.status === 401) { serverAuth = false; showToast('Not authenticated; changes saved locally', 'error'); } } catch (e) { showToast('Failed to save to server; saved locally', 'error'); } }
            localStorage.setItem(`ng_plugin_config_${serverId}_${id}`, JSON.stringify(data)); showToast('Saved locally', 'info'); closeWelcomeConfig();
          }
        }

        // Reset/test handlers wired after this block

        // Giveaway plugin modal handlers
        window.openGiveawayConfig = async function (id) {
          const modal = document.getElementById('plugin-modal-giveaway'); if (!modal) return showToast('Modal not available', 'error');
          const ch = document.getElementById('giveaway-modal-channel');
          const prize = document.getElementById('giveaway-modal-prize');
          const mention = document.getElementById('giveaway-modal-mention');
          const saveBtn = document.getElementById('giveaway-modal-save');
          const resetBtn = document.getElementById('giveaway-modal-reset');

          // load
          let obj = { giveaway: { duration: 60, channel: '', prize: '', mention: true } };
          try { if (serverAuth) { const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { credentials: 'include' }); if (res.ok) { const body = await res.json(); if (body && body.config) { const cfg = body.config[id] || body.config; if (cfg.giveaway) obj.giveaway = Object.assign({}, obj.giveaway, cfg.giveaway); else obj = Object.assign({}, obj, cfg); } } if (res.status === 401) serverAuth = false; } else { const raw = localStorage.getItem(`ng_plugin_config_${serverId}_${id}`); if (raw) obj = JSON.parse(raw); } } catch (e) { console.warn('Failed to load giveaway config', e); }

          // handle legacy duration (minutes) and new minutes+seconds
          const totalMinutes = (obj.giveaway && typeof obj.giveaway.duration !== 'undefined') ? Number(obj.giveaway.duration) : 60;
          const minutesPart = Math.floor(totalMinutes);
          const secondsPart = Math.round((totalMinutes - minutesPart) * 60) || 0;
          const minInput = document.getElementById('giveaway-modal-duration-min');
          const secInput = document.getElementById('giveaway-modal-duration-sec');
          if (minInput) minInput.value = String(minutesPart);
          if (secInput) secInput.value = String(Math.min(59, Math.max(0, secondsPart)));
          ch.value = (obj.giveaway && obj.giveaway.channel) || '';
          prize.value = (obj.giveaway && obj.giveaway.prize) || '';
          mention.checked = (obj.giveaway && typeof obj.giveaway.mention !== 'undefined') ? !!obj.giveaway.mention : true;

          syncModalTheme(modal); modal.setAttribute('aria-hidden', 'false'); modal.style.display = 'flex'; syncAutofillInModal(modal);

          // Prefetch activity immediately so the Activity section is ready when the user opens/switches to it
          try { if (typeof window.tryRefreshGiveawayActivity === 'function') { setTimeout(() => { try { window.tryRefreshGiveawayActivity(); } catch (e) { } }, 40); } } catch (e) { }

          const statusElem = document.getElementById('giveaway-modal-status');

          // clear status when min/sec inputs change
          if (minInput) { minInput.addEventListener('input', () => { if (statusElem) statusElem.textContent = ''; }); }
          if (secInput) { secInput.addEventListener('input', () => { if (statusElem) statusElem.textContent = ''; }); }

          // wire side panel options (switch sections and lazy-load data)
          const panelButtons = modal.querySelectorAll('.panel-option');
          const sectionBlocks = modal.querySelectorAll('.section-block');
          async function setActiveSection(s) {
            sectionBlocks.forEach(sb => { sb.style.display = (sb.dataset.section === s) ? 'block' : 'none'; });
            panelButtons.forEach(b => b.classList.toggle('active', b.dataset.section === s));
            if (s === 'activity') {
              try { if (typeof window.refreshGiveawayActivity === 'function') await window.refreshGiveawayActivity(); else console.warn('refreshGiveawayActivity not available'); } catch (e) { console.warn('refreshGiveawayActivity call failed', e); }
              return;
            }

          }
          console.log('Wiring giveaway side-panel handlers');
          // attach click handlers and add delegation as a fallback; add logs for debugging
          panelButtons.forEach(b => b.addEventListener('click', (ev) => { ev.preventDefault(); console.log('Giveaway panel clicked', b.dataset.section); try { if (typeof showToast === 'function') showToast('Opening ' + b.dataset.section, 'info'); } catch (e) { } setActiveSection(b.dataset.section); }));
          const side = modal.querySelector('.modal-side'); if (side) { side.addEventListener('click', (ev) => { const btn = ev.target.closest('.panel-option'); if (btn) { ev.preventDefault(); console.log('Delegated panel click', btn.dataset.section); try { if (typeof showToast === 'function') showToast('Opening ' + btn.dataset.section, 'info'); } catch (e) { } setActiveSection(btn.dataset.section); } }); }

          // extra fallback: document-level delegation in case modal scoping changes
          document.addEventListener('click', (ev) => {
            const btn = ev.target.closest('#plugin-modal-giveaway .panel-option');
            if (btn) {
              ev.preventDefault();
              console.log('Document delegated panel click', btn.dataset.section);
              try { if (typeof showToast === 'function') showToast('Opening ' + btn.dataset.section, 'info'); } catch (e) { }
              try { setActiveSection(btn.dataset.section); } catch (e) { }
              // Ensure Activity always refreshes when opened via panel click
              try { if (btn.dataset.section === 'activity') { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } } catch (e) { }
            }
          });

          // helper to immediately add a giveaway to the activity list (used after tests)
          window.addImmediateGiveawayToActivity = function (g) {
            try {
              const modalEl = document.getElementById('plugin-modal-giveaway'); if (!modalEl) return;
              const inner = document.getElementById('giveaway-activity-inner') || document.getElementById('giveaway-activity-list'); if (!inner) return;
              const gid = g.id || g.giveawayId || ('g-' + (g.ts || Date.now()));
              const prize = g.prize || '(no prize)';
              const createdAt = g.createdAt ? new Date(g.createdAt) : (g.ts ? new Date(g.ts) : new Date());
              const endsAt = g.endsAt ? new Date(g.endsAt) : (g.duration ? new Date(createdAt.getTime() + Number(g.duration) * 60 * 1000) : null);
              const creator = g.creatorName || (g.creator && g.creator.username) || (g.createdBy || g.creatorId) || 'You';
              const channelText = (g.channel && (g.channel.name || g.channel.id)) ? (g.channel.name ? '#' + g.channel.name : '#' + g.channel.id) : (g.channelId ? '#' + g.channelId : '‚Äî');
              const card = document.createElement('div'); card.className = 'giveaway-item'; card.setAttribute('data-test', g._isTest ? '1' : '0');
              card.innerHTML = `
            <div style="display:flex;gap:12px;align-items:flex-start">
              <div style="width:12px;height:12px;border-radius:999px;margin-top:6px;background:${(endsAt && Date.now() > endsAt.getTime()) ? 'var(--danger)' : '#3ad37f'};flex:0 0 12px"></div>
              <div style="flex:1">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
                  <div style="font-weight:700">${prize} ${g._isTest ? '<span class="test-badge">Test</span>' : ''} <span class="small-muted" style="font-weight:400">#${gid}</span></div>
                  <div class="small-muted">${createdAt ? createdAt.toLocaleString() : ''}</div>
                </div>
                <div class="small-muted" style="margin-top:6px">By <strong>${creator}</strong> ¬∑ Channel: ${channelText}</div>
                <div class="small-muted" style="margin-top:6px">Ends: ${endsAt ? (endsAt.toLocaleString()) : '‚Äî'} ¬∑ <span class="giveaway-remaining" data-gid="${gid}" data-ends="${endsAt ? endsAt.getTime() : ''}">${endsAt ? '‚Äî' : '‚Äî'}</span></div>
              </div>
              <div style="display:flex;flex-direction:column;gap:8px">
                <button class="btn ghost copy-id" data-id="${gid}">Copy ID</button>
                <button class="btn ghost view-winners" data-id="${gid}">Winners</button>
                <button class="btn ghost reroll-giveaway" data-id="${gid}">Reroll</button>
              </div>
            </div>`;
              // place into Running Giveaways area (prepend so newest are on top)
              const runHeader = inner.querySelector('div strong') ? inner.querySelector('div strong').closest('div') : null; // best-effort
              if (runHeader) { runHeader.insertAdjacentElement('afterend', card); } else { inner.prepend(card); }
              card.querySelectorAll('.copy-id').forEach(b => b.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(b.dataset.id); showToast('Copied giveaway ID', 'info'); });
              card.querySelectorAll('.view-winners').forEach(b => b.onclick = async () => {
                const gid = b.dataset.id;
                try {
                  const out = await window.fetchGiveawayWinners(gid, { tries: 3, delayMs: 700 });
                  if (out && out.winners && out.winners.length) {
                    try { const r = await fetch(`/api/giveaway-winners-resolve/${encodeURIComponent(serverId)}/${encodeURIComponent(gid)}`, { credentials: 'include' }); if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && Array.isArray(jb.resolved) && jb.resolved.length) { window.safeShowWinnersModal(gid, jb.resolved); return; } } } catch (e) { }
                    window.safeShowWinnersModal(gid, out.winners); return;
                  }
                  try { if (typeof showToast === 'function') showToast('No winners found yet. We retried contacting the bot and scanned recent activity. If you were the winner, try again in a few seconds.', 'info'); } catch (e) { console.info('No winners found yet'); }
                } catch (e) { console.warn('Failed to fetch winners', e); try { if (typeof showToast === 'function') showToast('Failed to fetch winners: ' + String(e), 'error'); } catch (e) { console.warn(e); } }
              });
              card.querySelectorAll('.reroll-giveaway').forEach(b => b.onclick = async () => { const gid = b.dataset.id; const origText = b.textContent; try { b.disabled = true; b.textContent = 'Rerolling‚Ä¶'; const r = await fetch(`/api/server-giveaway-reroll/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ giveawayId: gid }) }); if (r.ok) { showToast('Reroll requested', 'info'); try { b.textContent = origText; b.disabled = false; } catch (e) { } } else { let body = null; try { body = await r.json(); } catch (e) { body = { text: await r.text().catch(() => null) }; } const reason = (body && (body.details && (body.details.suggestion || body.details.error || body.details.message))) || body && (body.error || body.message) || body && body.text || 'Unknown'; showToast('Reroll failed: ' + reason, 'error'); console.warn('Reroll failed for', gid, 'status', r.status, 'reason', reason); try { b.textContent = origText; b.disabled = false; } catch (e) { } } } catch (e) { console.warn('Failed to reroll giveaway', e); showToast('Failed to reroll giveaway: ' + (e && e.message ? e.message : String(e)), 'error'); try { b.textContent = origText; b.disabled = false; } catch (e) { } } });
            } catch (e) { console.warn('addImmediateGiveawayToActivity failed', e); }
          };

          // helper to immediately add an activity-style entry (e.g., plugin_test) into Recent Giveaway Activity
          window.addImmediateActivityEntry = function (a) {
            try {
              const modalEl = document.getElementById('plugin-modal-giveaway'); if (!modalEl) return;
              const inner = document.getElementById('giveaway-activity-inner') || document.getElementById('giveaway-activity-list'); if (!inner) return;
              const gid = (a.payload && (a.payload.giveawayId || a.payload.id)) || (a.config && (a.config.giveawayId || a.config.id)) || ('activity-' + (a.ts || Date.now()));
              const prize = (a.payload && a.payload.prize) || (a.config && a.config.giveaway && a.config.giveaway.prize) || '(no prize)';
              const createdAt = a.ts ? new Date(a.ts) : new Date();
              let endsAt = null;
              if (a.payload) { if (a.payload.endsAt) endsAt = new Date(a.payload.endsAt); else if (a.payload.ends_at) endsAt = new Date(a.payload.ends_at); else if (a.payload.duration) endsAt = new Date(createdAt.getTime() + Number(a.payload.duration) * 60 * 1000); }
              if (!endsAt && a.config && a.config.giveaway && a.config.giveaway.duration) endsAt = new Date(createdAt.getTime() + Number(a.config.giveaway.duration) * 60 * 1000);
              const creator = a.user ? a.user.username : 'You';
              const channelText = (a.payload && a.payload.channelId) ? '#' + a.payload.channelId : '‚Äî';
              const isTest = (a.type === 'plugin_test') || a._isTest;

              const card = document.createElement('div'); card.className = 'giveaway-item'; card.dataset.gid = gid; card.setAttribute('data-test', isTest ? '1' : '0');
              card.innerHTML = `
            <div style="display:flex;gap:12px;align-items:flex-start">
              <div class="dot" style="background:${(endsAt && Date.now() > endsAt.getTime()) ? 'var(--danger)' : '#3ad37f'};flex:0 0 12px;margin-top:6px"></div>
              <div style="flex:1">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
                  <div style="font-weight:700">${prize} ${isTest ? '<span class="test-badge">Test</span>' : ''} <span class="small-muted" style="font-weight:400">#${gid}</span></div>
                  <div class="small-muted">${createdAt ? createdAt.toLocaleString() : ''}</div>
                </div>
                <div class="small-muted" style="margin-top:6px">By <strong>${creator}</strong> ¬∑ Channel: ${channelText}</div>
                <div class="small-muted" style="margin-top:6px">Ends: ${endsAt ? (endsAt.toLocaleString()) : '‚Äî'} ¬∑ <span class="giveaway-remaining" data-gid="${gid}" data-ends="${endsAt ? endsAt.getTime() : ''}">${endsAt ? '‚Äî' : '‚Äî'}</span></div>
              </div>
              <div style="display:flex;flex-direction:column;gap:8px">
                <button class="btn ghost copy-id" data-id="${gid}">Copy ID</button>
                <button class="btn ghost view-winners" data-id="${gid}">Winners</button>
                <button class="btn ghost reroll-giveaway" data-id="${gid}">Reroll</button>
              </div>
            </div>`;

              // Insert after the divider if present so Recent Activity section shows below Running Giveaways
              const divider = inner.querySelector('hr');
              if (divider && divider.parentNode) { divider.insertAdjacentElement('afterend', card); }
              else { inner.prepend(card); }

              card.querySelectorAll('.copy-id').forEach(b => b.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(b.dataset.id); showToast('Copied giveaway ID', 'info'); });
              card.querySelectorAll('.view-winners').forEach(b => b.onclick = async () => {
                const gid = b.dataset.id;
                try {
                  const out = await window.fetchGiveawayWinners(gid, { tries: 3, delayMs: 700 });
                  if (out && out.winners && out.winners.length) {
                    try { const r = await fetch(`/api/giveaway-winners-resolve/${encodeURIComponent(serverId)}/${encodeURIComponent(gid)}`, { credentials: 'include' }); if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && Array.isArray(jb.resolved) && jb.resolved.length) { window.safeShowWinnersModal(gid, jb.resolved); return; } } } catch (e) { }
                    window.safeShowWinnersModal(gid, out.winners); return;
                  }
                  try { if (typeof showToast === 'function') showToast('No winners found yet. We retried contacting the bot and scanned recent activity. If you were the winner, try again in a few seconds.', 'info'); } catch (e) { console.info('No winners found yet'); }
                } catch (e) { console.warn('Failed to fetch winners', e); try { if (typeof showToast === 'function') showToast('Failed to fetch winners: ' + String(e), 'error'); } catch (e) { console.warn(e); } }
              });
              card.querySelectorAll('.reroll-giveaway').forEach(b => b.onclick = async () => {
                const gid = b.dataset.id;
                try {
                  const res = await window.attemptRerollAndVerify(gid, { tries: 2, pollAttempts: 6, pollDelay: 1000 });
                  if (res && res.ok) { try { if (typeof showToast === 'function') showToast('Reroll succeeded', 'info'); } catch (e) { } if (res.winners && res.winners.length) { try { window.safeShowWinnersModal(gid, res.winners); } catch (e) { try { if (typeof showToast === 'function') showToast('New winners: ' + res.winners.join(', '), 'info'); } catch (e) { } } } try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { } return; }
                  if (res && res.status) { alert('Reroll request failed: ' + res.status + (res.text ? (' ‚àí ' + res.text) : '')); try { if (typeof showToast === 'function') showToast('Reroll failed', 'error'); } catch (e) { } return; }
                  const ok = confirm('Reroll did not complete (bot did not respond). Retry reroll?');
                  if (ok) {
                    try {
                      const r2 = await window.attemptRerollAndVerify(gid, { tries: 1, pollAttempts: 6, pollDelay: 1000 });
                      if (r2 && r2.ok) {
                        try { if (typeof showToast === 'function') showToast('Reroll succeeded', 'info'); } catch (e) { }
                        if (r2.winners && r2.winners.length) { try { window.safeShowWinnersModal(gid, r2.winners); } catch (e) { try { if (typeof showToast === 'function') showToast('New winners: ' + r2.winners.join(', '), 'info'); } catch (e) { } } }
                        try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                        return;
                      }
                      try { if (typeof showToast === 'function') showToast('Reroll retry failed or bot did not respond.', 'error'); } catch (e) { console.warn('Reroll retry failed or bot did not respond.'); }
                    } catch (e) {
                      console.warn('Reroll retry failed', e);
                      try { if (typeof showToast === 'function') showToast('Reroll retry failed: ' + String(e), 'error'); } catch (e) { console.warn('Reroll retry failed: ' + String(e)); }
                    }
                  }

                } catch (e) { console.warn('Failed to execute reroll', e); try { if (typeof showToast === 'function') showToast('Failed to reroll: ' + String(e), 'error'); } catch (e) { } }
              });
            } catch (e) { console.warn('addImmediateActivityEntry failed', e); }
          };

          // Helper: Try to get winners for a giveaway reliably by retrying giveaways endpoint and falling back to scanning recent activity
          window.fetchGiveawayWinners = async function (gid, opts) {
            opts = opts || {};
            const tries = typeof opts.tries === 'number' ? opts.tries : 3;
            const delayMs = typeof opts.delayMs === 'number' ? opts.delayMs : 700;
            // Try the giveaways endpoint a few times to allow the bot to update
            for (let i = 0; i < tries; i++) {
              try {
                const res = await fetch(`/api/server-giveaways/${encodeURIComponent(serverId)}?giveawayId=${encodeURIComponent(gid)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e }));
                if (res && res.ok) {
                  const body = await res.json().catch(() => null);
                  const g = body && (body.giveaways ? (body.giveaways || []).find(x => (x.id == gid || x.giveawayId == gid)) : (body && (body.giveaway || null)));
                  if (g) {
                    const winners = g.winners || g.winner || [];
                    if (Array.isArray(winners) && winners.length) return { source: 'giveaways', winners, giveaway: g };
                  }
                }
              } catch (e) { /* ignore and retry */ }
              if (i < tries - 1) await new Promise(r => setTimeout(r, delayMs));
            }

            // If giveaways did not return winners, scan recent activity for any entry that contains winners info
            try {
              const aRes = await fetch(`/api/server-activity/${encodeURIComponent(serverId)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e }));
              if (aRes && aRes.ok) {
                const aBody = await aRes.json().catch(() => ({ activity: [] }));
                const acts = aBody.activity || [];
                // prefer entries that mention this giveaway id in payload or config
                for (const a of acts) {
                  try {
                    if (!a) continue;
                    const payload = a.payload || a.data || {};
                    // winners could be in various shapes
                    const w = payload.winners || payload.winner || a.winners || null;
                    if (w && (Array.isArray(w) ? w.length : 1)) {
                      const winners = Array.isArray(w) ? w : [w];
                      return { source: 'activity', winners, activity: a };
                    }
                    // if payload references giveawayId and also contains a 'result' or 'winners' nested
                    if ((payload.giveawayId === gid || payload.id === gid || (payload.config && payload.config.giveaway && (payload.config.giveaway.id === gid || payload.config.giveaway.giveawayId === gid))) && (payload.winners || payload.winner)) {
                      const w2 = payload.winners || payload.winner || [];
                      const winners = Array.isArray(w2) ? w2 : [w2];
                      if (winners.length) return { source: 'activity', winners, activity: a };
                    }
                  } catch (e) { /* ignore candidate */ }
                }
              }
            } catch (e) { /* ignore */ }

            return null;
          };

          // Show winners modal; resolves member IDs to usernames from /api/guild-members and displays a popup
          window.showWinnersModal = async function (gid, winnerIds) {
            try {
              const existing = document.getElementById('winners-modal-overlay'); if (existing) existing.remove();
              const overlay = document.createElement('div'); overlay.id = 'winners-modal-overlay'; overlay.className = 'winners-modal-overlay';
              const card = document.createElement('div'); card.className = 'winners-modal-card';
              card.innerHTML = `<h4>Winners for #${gid}</h4><div class="winners-resolving-status">Resolving winners‚Ä¶</div><div id="winners-modal-list"><p class="winners-empty">Resolving winners‚Ä¶</p></div><div class="winners-modal-actions"><button id="winners-copy-all" class="btn ghost">Copy All IDs</button><button id="winners-test" class="btn ghost">Test resolution</button><button id="winners-close" class="btn">Close</button></div>`;
              overlay.appendChild(card); document.body.appendChild(overlay);

              const statusEl = card.querySelector('.winners-resolving-status');
              const listEl = card.querySelector('#winners-modal-list');
              // debug panel (visible in-modal to help diagnose resolution failures)
              const debugPre = document.createElement('pre'); debugPre.className = 'winners-debug-pre'; debugPre.style.whiteSpace = 'pre-wrap'; debugPre.style.margin = '6px 0 8px 0'; debugPre.style.color = 'var(--muted)'; debugPre.textContent = '';
              const debugActions = document.createElement('div'); debugActions.style.display = 'flex'; debugActions.style.justifyContent = 'flex-end'; debugActions.style.gap = '8px';
              const debugRetry = document.createElement('button'); debugRetry.className = 'btn ghost'; debugRetry.textContent = 'Retry unresolved'; debugRetry.onclick = () => { try { debugResolveUnresolved(); } catch (e) { console.warn('Retry failed', e); } };
              debugActions.appendChild(debugRetry);
              // insert debug panel below status and wire debug buttons
              if (statusEl) { statusEl.parentNode.insertBefore(debugPre, listEl); statusEl.parentNode.insertBefore(debugActions, listEl); }
              // wire test & retry buttons
              const testBtn = card.querySelector('#winners-test'); if (testBtn) { testBtn.onclick = () => { try { testResolution(winnerIds); } catch (e) { console.warn('Test resolution failed', e); } } }

              const retryBtn = debugActions.querySelector('button'); if (retryBtn) { retryBtn.onclick = () => { try { debugResolveUnresolved(); } catch (e) { console.warn('Retry unresolved failed', e); } } }

              console.debug('showWinnersModal', { guildId: serverId, giveawayId: gid, winnerIds });

              // helper to update debug lines
              function updateDebug(id, text) { try { const re = new RegExp('^' + id + ':.*$', 'm'); if (re.test(debugPre.textContent || '')) { debugPre.textContent = (debugPre.textContent || '').replace(re, id + ': ' + text); } else { debugPre.textContent = (debugPre.textContent || '') + id + ': ' + text + '\n'; } } catch (e) { /* ignore */ } }

              // Test resolution for all winners (invoked by Test button)
              async function testResolution(ids) {
                if (!Array.isArray(ids)) ids = Array.isArray(ids) ? ids : (ids ? [ids] : []);
                if (!ids || ids.length === 0) return;
                statusEl && (statusEl.textContent = `Testing ${ids.length} member(s)‚Ä¶`);
                for (const id of ids) {
                  updateDebug(id, 'testing‚Ä¶');
                  try {
                    const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(id)}`, { credentials: 'include' });
                    if (!r) { updateDebug(id, 'no response'); continue; }
                    updateDebug(id, 'http ' + r.status);
                    if (r.status === 501) { // server not configured
                      statusEl && (statusEl.textContent = 'Server not configured to resolve members (BOT_TOKEN missing)');
                      try { if (typeof showToast === 'function') showToast('Server not configured to resolve members (BOT_TOKEN missing)', 'error'); } catch (e) { }
                      continue;
                    }
                    if (r.ok) {
                      const jb = await r.json().catch(() => null); if (jb && jb.member) { const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); const av = card.querySelector('.winner-avatar[data-winner-id="' + id + '"]'); if (el) { el.href = 'https://discord.com/users/' + jb.member.id; el.textContent = '@' + jb.member.username; el.classList.remove('winner-resolving'); updateDebug(id, 'resolved: @' + jb.member.username); } if (av && jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { av.style.backgroundImage = 'url(' + _u + ')'; av.style.backgroundSize = 'cover'; av.classList.remove('placeholder'); av.textContent = ''; } } }
                    } else {
                      updateDebug(id, 'http ' + r.status + ' (failed)');
                    }
                  } catch (e) { updateDebug(id, 'exception: ' + (e && e.message ? e.message : String(e))); }
                }
                statusEl && (statusEl.textContent = 'Test complete');
              }

              // Retry unresolved members from the debug panel
              async function debugResolveUnresolved() {
                const unresolved = Array.from(card.querySelectorAll('.winner-mention.winner-resolving')).map(el => el.getAttribute('data-winner-id')).filter(Boolean);
                if (!unresolved.length) return;
                statusEl && (statusEl.textContent = `Resolving ${unresolved.length} member(s)‚Ä¶`);

                for (const id of unresolved) {
                  updateDebug(id, 'retrying‚Ä¶');
                  try {
                    const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(id)}`, { credentials: 'include' });
                    if (r && r.ok) {
                      const jb = await r.json().catch(() => null);
                      if (jb && jb.member) {
                        const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]');
                        const av = card.querySelector('.winner-avatar[data-winner-id="' + id + '"]');
                        if (el) {
                          el.href = 'https://discord.com/users/' + jb.member.id;
                          el.textContent = '@' + jb.member.username;
                          el.classList.remove('winner-resolving');
                          updateDebug(id, 'resolved: @' + jb.member.username);
                        }
                        if (av && jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { av.style.backgroundImage = 'url(' + _u + ')'; av.style.backgroundSize = 'cover'; av.classList.remove('placeholder'); av.textContent = ''; } }
                        continue;
                      }
                    }

                    // not ok or no member returned
                    updateDebug(id, 'still unresolved');
                    try { const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved)'; } } catch (e2) { }
                  } catch (e) {
                    updateDebug(id, 'error: ' + (e && e.message ? e.message : String(e)));
                    try { const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved)'; } } catch (e2) { }
                  }
                }

                statusEl && (statusEl.textContent = 'Resolution complete');
              }

              // Ensure we have an array
              winnerIds = Array.isArray(winnerIds) ? winnerIds : (winnerIds ? [winnerIds] : []);

              // Try server-side resolution for this giveaway (so the dashboard can return usernames/avatars in one call)
              try {
                const r = await fetch(`/api/giveaway-winners-resolve/${encodeURIComponent(serverId)}/${encodeURIComponent(gid)}`, { credentials: 'include' });
                if (r && r.ok) { let jb = null; try { jb = await r.json(); } catch (e) { jb = null; } if (jb && Array.isArray(jb.resolved) && jb.resolved.length) { winnerIds = jb.resolved.map(m => (m && m.id) ? m : (typeof m === 'string' ? { id: m } : { id: String(m) })); } }
              } catch (e) { /* ignore resolution failure and continue with client-side lookups */ }

              // Try to resolve via guild members endpoint (initial cache)
              let membersMap = {};
              try {
                const mRes = await fetch(`/api/guild-members/${encodeURIComponent(serverId)}?limit=200`, { credentials: 'include' });
                if (mRes && mRes.ok) { const mb = await mRes.json().catch(() => null); if (mb && Array.isArray(mb.members)) { mb.members.forEach(m => { membersMap[String(m.id)] = m; }); } }
                console.debug('initial membersMap size', Object.keys(membersMap).length);
                if (typeof updateDebug === 'function') try { updateDebug('membersMap', 'size: ' + Object.keys(membersMap).length); } catch (e) { }
              } catch (e) { console.warn('Failed to fetch /api/guild-members', e); statusEl && (statusEl.textContent = 'Failed to fetch member list (will attempt per-id lookups)'); }

              // Build list
              listEl.innerHTML = '';
              if (!winnerIds || winnerIds.length === 0) { listEl.innerHTML = '<p class="winners-empty">No winners found yet.</p>'; }
              else {
                // session cache to avoid repeated per-id lookups
                const _winnersMembersCache = window._winnersMembersCache = window._winnersMembersCache || {};
                for (const item of winnerIds) {
                  const id = (typeof item === 'string') ? item : (item && item.id ? String(item.id) : String(item));
                  const m = (item && typeof item === 'object' && item.username) ? item : membersMap[String(id)];

                  const row = document.createElement('div'); row.className = 'winner-row';
                  const avatar = document.createElement('div'); avatar.className = 'winner-avatar';
                  if (m && m.avatar) { const _u = discordAvatarUrl(m.id, m.avatar, 64); if (_u) { avatar.style.backgroundImage = 'url(' + _u + ')'; avatar.style.backgroundSize = 'cover'; avatar.classList.remove('placeholder'); avatar.textContent = ''; } }
                  else { avatar.classList.add('placeholder'); avatar.textContent = (m && m.username) ? (m.username[0] || '?').toUpperCase() : '?'; }

                  const meta = document.createElement('div'); meta.className = 'winner-meta';

                  // User line: label + mention (anchor when possible)
                  const userLine = document.createElement('div'); userLine.className = 'winner-field';
                  const userLabel = document.createElement('span'); userLabel.className = 'winner-label'; userLabel.textContent = 'User: ';
                  let mention = document.createElement('a'); mention.className = 'winner-mention'; mention.target = '_blank'; mention.rel = 'noopener noreferrer';

                  if (m && m.username) {
                    mention.href = 'https://discord.com/users/' + m.id;
                    mention.textContent = '@' + m.username;
                  } else {
                    // show Resolving placeholder while we attempt per-id lookup
                    mention.href = 'https://discord.com/users/' + id; mention.textContent = 'Resolving‚Ä¶'; mention.classList.add('winner-resolving');
                  }

                  // tag elements so we can batch-resolve after rendering
                  mention.setAttribute('data-winner-id', id);
                  avatar.setAttribute('data-winner-id', id);
                  userLine.appendChild(userLabel); userLine.appendChild(mention);

                  // ID line: label + id
                  const idLine = document.createElement('div'); idLine.className = 'winner-field';
                  const idLabel = document.createElement('span'); idLabel.className = 'winner-label'; idLabel.textContent = 'ID: ';
                  const idVal = document.createElement('span'); idVal.className = 'winner-id'; idVal.textContent = id;
                  idLine.appendChild(idLabel); idLine.appendChild(idVal);

                  meta.appendChild(userLine); meta.appendChild(idLine);

                  const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.gap = '8px';
                  const copyBtn = document.createElement('button'); copyBtn.className = 'btn ghost'; copyBtn.textContent = 'Copy ID'; copyBtn.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(id); try { if (typeof showToast === 'function') showToast('Copied ID', 'info'); } catch (e) { } };
                  actions.appendChild(copyBtn);

                  row.appendChild(avatar); row.appendChild(meta); row.appendChild(actions);
                  listEl.appendChild(row);

                  // if not resolved, try a per-id lookup and update the row when it returns
                  if ((!m || !m.username) && serverId) {
                    (async function (_id, _avatarEl, _userLineEl, _mentionEl, _meta) {
                      try {
                        if (_winnersMembersCache[_id]) {
                          const mm = _winnersMembersCache[_id];
                          membersMap[String(_id)] = mm;
                          // update user line
                          _mentionEl.href = 'https://discord.com/users/' + mm.id;
                          _mentionEl.textContent = '@' + mm.username;
                          if (mm.avatar) { const _u = discordAvatarUrl(mm.id, mm.avatar, 64); if (_u) { _avatarEl.style.backgroundImage = 'url(' + _u + ')'; _avatarEl.style.backgroundSize = 'cover'; _avatarEl.classList.remove('placeholder'); _avatarEl.textContent = ''; } }
                          return;
                        }
                        const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(_id)}`, { credentials: 'include' });
                        if (r && r.ok) {
                          const jb = await r.json().catch(() => null);
                          if (jb && jb.member) {
                            _winnersMembersCache[_id] = jb.member;
                            membersMap[String(_id)] = jb.member;
                            _mentionEl.href = 'https://discord.com/users/' + jb.member.id;
                            _mentionEl.textContent = '@' + jb.member.username;
                            if (jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { _avatarEl.style.backgroundImage = 'url(' + _u + ')'; _avatarEl.style.backgroundSize = 'cover'; _avatarEl.classList.remove('placeholder'); _avatarEl.textContent = ''; } }
                          }
                        }
                      } catch (e) { /* ignore per-id lookup failures */ }
                    })(id, avatar, userLine, mention, meta);
                  }
                }
              }

              // Batch per-id lookups for any unresolved mentions (helpful if initial members list missed them)
              (async function () {
                // initialize debug status lines for all winners
                for (const id of winnerIds) { updateDebug(id, membersMap[String(id)] ? ('initial: @' + (membersMap[String(id)].username || '')) : 'pending per-id lookup'); }
                const unresolved = Array.from(card.querySelectorAll('.winner-mention.winner-resolving')).map(el => el.getAttribute('data-winner-id')).filter(Boolean);
                if (unresolved.length) { if (statusEl) statusEl.textContent = `Resolving ${unresolved.length} member(s)‚Ä¶`; }
                let failed = false; let botTokenMissing = false;
                await Promise.all(unresolved.map(async function (id) {
                  try {
                    console.debug('batch lookup for winner', id);
                    const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(id)}`, { credentials: 'include' });
                    if (r && r.status === 501) { botTokenMissing = true; failed = true; const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved: server not configured)'; } updateDebug(id, 'unresolved: server not configured'); return; }
                    if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && jb.member) { const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); const av = card.querySelector('.winner-avatar[data-winner-id="' + id + '"]'); if (el) { el.href = 'https://discord.com/users/' + jb.member.id; el.textContent = '@' + jb.member.username; el.classList.remove('winner-resolving'); } if (av && jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { av.style.backgroundImage = 'url(' + _u + ')'; av.style.backgroundSize = 'cover'; av.classList.remove('placeholder'); av.textContent = ''; } } updateDebug(id, 'resolved: @' + jb.member.username); return; } }
                    const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved)'; failed = true; updateDebug(id, 'unresolved'); }
                  } catch (e) { console.warn('batch lookup exception', id, e); const el = card.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved)'; failed = true; updateDebug(id, 'exception: ' + (e && e.message ? e.message : String(e))); } }
                }));
                if (statusEl) statusEl.textContent = 'Resolution complete';
                if (botTokenMissing) { try { if (typeof showToast === 'function') showToast('Server not configured to resolve members (BOT_TOKEN missing)', 'error'); } catch (e) { } if (statusEl) statusEl.textContent = 'Server not configured to resolve members (BOT_TOKEN missing)'; }
                else if (failed) { try { if (typeof showToast === 'function') showToast('Failed to resolve some winners (see server logs)', 'error'); } catch (e) { } if (statusEl) statusEl.textContent = 'Some winners could not be resolved'; }
              })();

              card.querySelector('#winners-copy-all').onclick = () => { try { navigator.clipboard && navigator.clipboard.writeText((winnerIds || []).join('\n')); if (typeof showToast === 'function') showToast('Copied IDs', 'info'); } catch (e) { } };

              // close on Esc or overlay click
              overlay.addEventListener('click', (ev) => { if (ev.target === overlay) { overlay.remove(); } });
              document.addEventListener('keydown', function onKey(ev) { if (ev.key === 'Escape') { overlay.remove(); document.removeEventListener('keydown', onKey); } });

            } catch (e) {
              console.warn('Failed to show winners modal', e);
              try {
                const existing = document.getElementById('winners-modal-overlay'); if (existing) existing.remove();
                const overlay = document.createElement('div'); overlay.id = 'winners-modal-overlay'; overlay.className = 'winners-modal-overlay';
                const card = document.createElement('div'); card.className = 'winners-modal-card';
                card.innerHTML = `<h4>Winners for #${gid}</h4><div id="winners-modal-list"></div><div class="winners-modal-actions"><button id="winners-close" class="btn">Close</button></div>`;
                const list = card.querySelector('#winners-modal-list');
                // build a simple list showing mention and id
                if (!winnerIds || winnerIds.length === 0) { list.innerHTML = '<p class="winners-empty">No winners found.</p>'; }
                else {
                  for (const id of (Array.isArray(winnerIds) ? winnerIds : [winnerIds])) {
                    const row = document.createElement('div'); row.className = 'winner-row';
                    const avatar = document.createElement('div'); avatar.className = 'winner-avatar';
                    const meta = document.createElement('div'); meta.className = 'winner-meta';

                    const userLine = document.createElement('div'); userLine.className = 'winner-field';
                    const userLabel = document.createElement('span'); userLabel.className = 'winner-label'; userLabel.textContent = 'User: ';
                    const mention = document.createElement('a'); mention.className = 'winner-mention'; mention.href = 'https://discord.com/users/' + id; mention.target = '_blank'; mention.rel = 'noopener noreferrer'; mention.textContent = '@' + id;
                    // tag for batch resolution
                    mention.setAttribute('data-winner-id', id);
                    avatar.setAttribute('data-winner-id', id);
                    userLine.appendChild(userLabel); userLine.appendChild(mention);

                    const idLine = document.createElement('div'); idLine.className = 'winner-field';
                    const idLabel = document.createElement('span'); idLabel.className = 'winner-label'; idLabel.textContent = 'ID: ';
                    const idVal = document.createElement('span'); idVal.className = 'winner-id'; idVal.textContent = id;
                    idLine.appendChild(idLabel); idLine.appendChild(idVal);

                    meta.appendChild(userLine); meta.appendChild(idLine);
                    const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.gap = '8px';
                    const copyBtn = document.createElement('button'); copyBtn.className = 'btn ghost'; copyBtn.textContent = 'Copy ID'; copyBtn.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(id); try { if (typeof showToast === 'function') showToast('Copied ID', 'info'); } catch (e) { } };
                    actions.appendChild(copyBtn);
                    row.appendChild(avatar); row.appendChild(meta); row.appendChild(actions);
                    list.appendChild(row);

                    // attempt per-id lookup to enrich fallback where possible
                    (async function (_id, _avatarEl, _mentionEl) {
                      try {
                        const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(_id)}`, { credentials: 'include' });
                        if (r && r.ok) { let jb = null; try { jb = await r.json(); } catch (e) { jb = null; } if (jb && jb.member) { _mentionEl.href = 'https://discord.com/users/' + jb.member.id; _mentionEl.textContent = '@' + jb.member.username; if (jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { _avatarEl.style.backgroundImage = 'url(' + _u + ')'; _avatarEl.style.backgroundSize = 'cover'; _avatarEl.classList.remove('placeholder'); _avatarEl.textContent = ''; } } } }
                      } catch (e) { /* ignore */ }
                    })(id, avatar, mention);
                  }
                }

                // Batch-resolve any remaining unresolved mentions (saves multiple network hits and surfaces failures)
                (async function () {
                  const unresolved = Array.from(list.querySelectorAll('.winner-mention')).filter(el => el && (el.textContent || '').indexOf('@') === 0 && el.classList.contains('winner-resolving')).map(el => el.getAttribute('data-winner-id')).filter(Boolean);
                  if (unresolved.length) {
                    let failed = false; let botTokenMissing = false;
                    await Promise.all(unresolved.map(async function (id) {
                      try {
                        const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(id)}`, { credentials: 'include' });
                        if (r && r.status === 501) { botTokenMissing = true; failed = true; const el = list.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved: server not configured)'; } return; }
                        if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && jb.member) { const el = list.querySelector('.winner-mention[data-winner-id="' + id + '"]'); const av = list.querySelector('.winner-avatar[data-winner-id="' + id + '"]'); if (el) { el.href = 'https://discord.com/users/' + jb.member.id; el.textContent = '@' + jb.member.username; el.classList.remove('winner-resolving'); } if (av && jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { av.style.backgroundImage = 'url(' + _u + ')'; av.style.backgroundSize = 'cover'; av.classList.remove('placeholder'); av.textContent = ''; } } return; } }
                        const el = list.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved)'; failed = true; }
                      } catch (e) { const el = list.querySelector('.winner-mention[data-winner-id="' + id + '"]'); if (el) { el.classList.remove('winner-resolving'); el.classList.add('winner-unresolved'); el.textContent = '@' + id + ' (unresolved)'; failed = true; } }
                    }));
                    if (botTokenMissing) { try { if (typeof showToast === 'function') showToast('Server not configured to resolve members (BOT_TOKEN missing)', 'error'); } catch (e) { } if (statusEl) statusEl.textContent = 'Server not configured to resolve members (BOT_TOKEN missing)'; }
                    else if (failed) { try { if (typeof showToast === 'function') showToast('Failed to resolve some winners (see server logs)', 'error'); } catch (e) { } if (statusEl) statusEl.textContent = 'Some winners could not be resolved'; }
                  }
                })();

                overlay.appendChild(card); document.body.appendChild(overlay);
                card.querySelector('#winners-close').onclick = () => { overlay.remove(); };
                overlay.addEventListener('click', (ev) => { if (ev.target === overlay) overlay.remove(); });
              } catch (e2) { console.warn('Also failed to show fallback winners modal', e2); }
            }
          };

          // Safe wrapper: call `showWinnersModal` if available, otherwise render a simple fallback overlay
          window.safeShowWinnersModal = function (gid, winnerIds) {
            try { if (typeof window.showWinnersModal === 'function') return window.showWinnersModal(gid, winnerIds); } catch (e) { }
            try {
              // Build a more helpful fallback UI that attempts per-id resolution
              const existing = document.getElementById('winners-modal-overlay'); if (existing) existing.remove();
              const overlay = document.createElement('div'); overlay.id = 'winners-modal-overlay'; overlay.className = 'winners-modal-overlay';
              const card = document.createElement('div'); card.className = 'winners-modal-card';
              const title = document.createElement('h4'); title.textContent = gid ? ('Winners for #' + gid) : 'Winners';
              const list = document.createElement('div'); list.id = 'winners-modal-list'; list.style.marginTop = '8px';
              const actions = document.createElement('div'); actions.className = 'winners-modal-actions';
              const copyAll = document.createElement('button'); copyAll.className = 'btn ghost'; copyAll.id = 'winners-copy-all'; copyAll.textContent = 'Copy All IDs';
              copyAll.onclick = () => { try { navigator.clipboard && navigator.clipboard.writeText((Array.isArray(winnerIds) ? winnerIds.join('\n') : String(winnerIds || ''))); if (typeof showToast === 'function') showToast('Copied IDs', 'info'); } catch (e) { } };
              const close = document.createElement('button'); close.className = 'btn'; close.id = 'winners-close'; close.textContent = 'Close'; close.onclick = () => { overlay.remove(); };
              actions.appendChild(copyAll); actions.appendChild(close);

              const statusEl = document.createElement('div'); statusEl.className = 'winners-resolving-status'; statusEl.textContent = 'Resolving‚Ä¶';
              card.appendChild(title); card.appendChild(statusEl); card.appendChild(list); card.appendChild(actions);
              overlay.appendChild(card); document.body.appendChild(overlay);

              // If we don't have full details, show resolvers per-id
              winnerIds = Array.isArray(winnerIds) ? winnerIds : (winnerIds ? [winnerIds] : []);
              if (!winnerIds || winnerIds.length === 0) { list.innerHTML = '<p class="winners-empty">No winners found.</p>'; return; }

              const cache = window._winnersMembersCache = window._winnersMembersCache || {};
              let _perIdLookupFailedShown = false;
              // visual resolver state
              let _remainingToResolve = winnerIds.length;
              if (statusEl) statusEl.textContent = `Resolving ${_remainingToResolve} member(s)‚Ä¶`;
              const _markResolved = () => { _remainingToResolve = Math.max(0, _remainingToResolve - 1); if (statusEl) statusEl.textContent = _remainingToResolve > 0 ? `Resolving ${_remainingToResolve} member(s)‚Ä¶` : `All attempted`; }

              for (const id of winnerIds) {
                const row = document.createElement('div'); row.className = 'winner-row';
                const avatar = document.createElement('div'); avatar.className = 'winner-avatar';
                const meta = document.createElement('div'); meta.className = 'winner-meta';

                const userLine = document.createElement('div'); userLine.className = 'winner-field';
                const userLabel = document.createElement('span'); userLabel.className = 'winner-label'; userLabel.textContent = 'User: ';
                const mention = document.createElement('a'); mention.className = 'winner-mention'; mention.href = 'https://discord.com/users/' + id; mention.target = '_blank'; mention.rel = 'noopener noreferrer';
                mention.textContent = cache[id] ? ('@' + cache[id].username) : ('@' + id);
                userLine.appendChild(userLabel); userLine.appendChild(mention);

                const idLine = document.createElement('div'); idLine.className = 'winner-field';
                const idLabel = document.createElement('span'); idLabel.className = 'winner-label'; idLabel.textContent = 'ID: ';
                const idVal = document.createElement('span'); idVal.className = 'winner-id'; idVal.textContent = id;
                idLine.appendChild(idLabel); idLine.appendChild(idVal);

                meta.appendChild(userLine); meta.appendChild(idLine);

                const actionsCol = document.createElement('div'); actionsCol.style.display = 'flex'; actionsCol.style.gap = '8px';
                const copyBtn = document.createElement('button'); copyBtn.className = 'btn ghost'; copyBtn.textContent = 'Copy ID'; copyBtn.onclick = () => { try { navigator.clipboard && navigator.clipboard.writeText(id); if (typeof showToast === 'function') showToast('Copied ID', 'info'); } catch (e) { } };
                actionsCol.appendChild(copyBtn);

                row.appendChild(avatar); row.appendChild(meta); row.appendChild(actionsCol);
                list.appendChild(row);

                // attempt per-id lookup to fill details
                (async function (_id, _avatarEl, _mentionEl, _row) {
                  try {
                    if (cache[_id]) {
                      // already have it
                      const mm = cache[_id];
                      _mentionEl.href = 'https://discord.com/users/' + mm.id;
                      _mentionEl.textContent = '@' + mm.username;
                      _mentionEl.classList.remove('winner-resolving');
                      if (mm.avatar) { const _u = discordAvatarUrl(mm.id, mm.avatar, 64); if (_u) { _avatarEl.style.backgroundImage = 'url(' + _u + ')'; _avatarEl.style.backgroundSize = 'cover'; _avatarEl.classList.remove('placeholder'); _avatarEl.textContent = ''; } }
                      _markResolved();
                      return;
                    }

                    // mark as resolving (visual) and attempt lookup
                    _mentionEl.classList.add('winner-resolving');
                    console.debug('Attempting per-id lookup for', _id);
                    const r = await fetch(`/api/guild-member/${encodeURIComponent(serverId)}/${encodeURIComponent(_id)}`, { credentials: 'include' });
                    if (r && r.ok) {
                      const jb = await r.json().catch(() => null);
                      if (jb && jb.member) {
                        cache[_id] = jb.member;
                        _mentionEl.href = 'https://discord.com/users/' + jb.member.id;
                        _mentionEl.textContent = '@' + jb.member.username;
                        _mentionEl.classList.remove('winner-resolving');
                        if (jb.member.avatar) { const _u = discordAvatarUrl(jb.member.id, jb.member.avatar, 64); if (_u) { _avatarEl.style.backgroundImage = 'url(' + _u + ')'; _avatarEl.style.backgroundSize = 'cover'; _avatarEl.classList.remove('placeholder'); _avatarEl.textContent = ''; } }
                        return;
                      }
                    }

                    // if we reach here, lookup failed
                    console.warn('Per-id lookup failed or returned no member for', _id, r && r.status);
                    _mentionEl.classList.remove('winner-resolving');
                    _mentionEl.textContent = '@' + _id + ' (unresolved)';
                    _mentionEl.classList.add('winner-unresolved');
                    if (!_perIdLookupFailedShown) { try { if (typeof showToast === 'function') showToast('Failed to resolve some winners (see server logs)', 'error'); } catch (e) { } _perIdLookupFailedShown = true; }
                  } catch (e) { console.warn('Per-id lookup exception for', _id, e); _mentionEl.classList.remove('winner-resolving'); _mentionEl.textContent = '@' + _id + ' (unresolved)'; _mentionEl.classList.add('winner-unresolved'); if (!_perIdLookupFailedShown) { try { if (typeof showToast === 'function') showToast('Failed to resolve some winners (see server logs)', 'error'); } catch (e) { } _perIdLookupFailedShown = true; } }
                })(id, avatar, mention, row);
              }

              overlay.addEventListener('click', (ev) => { if (ev.target === overlay) overlay.remove(); });
            } catch (e) { try { if (typeof showToast === 'function') showToast('Winners: ' + (Array.isArray(winnerIds) ? winnerIds.join(', ') : String(winnerIds || '')), 'info'); } catch (e) { } }
          };

          // Ensure `window.showWinnersModal` exists (alias to safe) so direct calls won't throw
          if (!window.showWinnersModal || typeof window.showWinnersModal !== 'function') window.showWinnersModal = function (gid, winnerIds) { window.safeShowWinnersModal(gid, winnerIds); };

          // Intercept legacy/native alerts for winners/reroll and show the custom UI instead ‚úÖ
          (function () {
            const _alert = window.alert; window.alert = function (msg) {
              try {
                if (typeof msg === 'string' && msg.indexOf('Winners:') === 0) { const idsStr = msg.replace(/^Winners:\s*/, '').trim(); const ids = idsStr ? idsStr.split(/\s*,\s*/).map(s => s.trim()) : []; if (ids.length) { try { window.safeShowWinnersModal && window.safeShowWinnersModal('', ids); } catch (e) { try { if (typeof showToast === 'function') showToast('Winners: ' + ids.join(', '), 'info'); } catch (e) { } } return; } }
                if (typeof msg === 'string' && msg.indexOf('New winners:') === 0) { const idsStr = msg.replace(/^New winners:\s*/, '').trim(); const ids = idsStr ? idsStr.split(/\s*,\s*/).map(s => s.trim()) : []; if (ids.length) { try { window.safeShowWinnersModal && window.safeShowWinnersModal('', ids); } catch (e) { try { if (typeof showToast === 'function') showToast('New winners: ' + ids.join(', '), 'info'); } catch (e) { } } return; } }
                if (typeof msg === 'string' && msg.indexOf('Reroll') !== -1) { try { if (typeof showToast === 'function') showToast(msg, 'error'); return; } catch (e) { } }
              } catch (e) { }
              _alert(msg);
            };
          })();

          // clear timers
          if (modalEl._giveawayActivityTimer) { clearInterval(modalEl._giveawayActivityTimer); modalEl._giveawayActivityTimer = null; }
          if (modalEl._giveawayActivityPoll) { clearInterval(modalEl._giveawayActivityPoll); modalEl._giveawayActivityPoll = null; }
          if (modalEl._giveawayAutoRefresh) { clearInterval(modalEl._giveawayAutoRefresh); modalEl._giveawayAutoRefresh = null; }
          try {
            try { const status = document.getElementById('giveaway-activity-status'); if (status) status.textContent = 'Fetching‚Ä¶'; } catch (e) { }
            const debugPre = (function () { try { const inner = document.getElementById('giveaway-activity-inner'); if (!inner) return null; let pre = inner.querySelector('#giveaway-activity-debug-pre'); if (!pre) { pre = document.createElement('pre'); pre.id = 'giveaway-activity-debug-pre'; pre.style.whiteSpace = 'pre-wrap'; pre.style.fontSize = '0.75rem'; pre.style.marginTop = '8px'; pre.style.color = 'var(--muted)'; inner.appendChild(pre); } pre.textContent = 'Starting fetch...'; return pre; } catch (e) { return null; } })();
            const [gRes, aRes] = await Promise.all([
              fetch(`/api/server-giveaways/${encodeURIComponent(serverId)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e })),
              fetch(`/api/server-activity/${encodeURIComponent(serverId)}`, { credentials: 'include' }).catch(e => ({ ok: false, _err: e }))
            ]);
            let gBody = { giveaways: [] }, aBody = { activity: [] };
            try { if (gRes && gRes.ok) { gBody = await gRes.json().catch(() => ({ giveaways: [] })); } else { try { if (debugPre) debugPre.textContent = (debugPre.textContent || '') + '\nGiveaways fetch failed: ' + (gRes && gRes.status ? gRes.status : String(gRes && gRes._err || 'unknown')); } catch (e) { } } } catch (e) { console.warn('Failed to parse giveaways JSON', e); if (debugPre) debugPre.textContent = (debugPre.textContent || '') + '\nFailed to parse giveaways JSON: ' + String(e); }
            try { if (aRes && aRes.ok) { aBody = await aRes.json().catch(() => ({ activity: [] })); } else { try { if (debugPre) debugPre.textContent = (debugPre.textContent || '') + '\nActivity fetch failed: ' + (aRes && aRes.status ? aRes.status : String(aRes && aRes._err || 'unknown')); } catch (e) { } } } catch (e) { console.warn('Failed to parse activity JSON', e); if (debugPre) debugPre.textContent = (debugPre.textContent || '') + '\nFailed to parse activity JSON: ' + String(e); }
            const giveaways = gBody && gBody.giveaways ? gBody.giveaways : [];
            const activities = (aBody && aBody.activity ? aBody.activity : []).filter(x => {
              try {
                if (!x) return false;
                if (x.type === 'plugin_test') return true;
                if (x.pluginId && String(x.pluginId).toLowerCase().includes('giveaway')) return true;
                if (x.payload && (x.payload.giveawayId || x.payload.id || x.payload.prize || x.payload.duration || x.payload.endsAt || x.payload.ends_at)) return true;
                if (x.config && x.config.giveaway) return true;
                return false;
              } catch (e) { return false; }
            });
            try { if (debugPre) debugPre.textContent = (debugPre.textContent || '') + '\nFetched giveaways: ' + (giveaways.length) + ', activities: ' + (activities.length); } catch (e) { }
            console.log('refreshGiveawayActivity fetched', { giveaways: (gBody && gBody.giveaways ? (gBody.giveaways.length || 0) : 0), activities: activities.length });

            // show a minimal summary so we always render something even when card rendering fails
            try {
              const innerPreview = document.getElementById('giveaway-activity-summary');
              if (innerPreview) { innerPreview.textContent = `Giveaways: ${giveaways.length} ‚Ä¢ Activities: ${activities.length}`; }
              else if (document.getElementById('giveaway-activity-inner')) {
                const s = document.createElement('div'); s.id = 'giveaway-activity-summary'; s.className = 'small-muted'; s.style.marginTop = '6px'; s.textContent = `Giveaways: ${giveaways.length} ‚Ä¢ Activities: ${activities.length}`;
                document.getElementById('giveaway-activity-inner').appendChild(s);
              }
            } catch (e) { /* ignore */ }

            // compute signatures and decide whether we need to update the DOM
            try {
              if (activities && activities.length) console.log('first activity sample', activities[0]);
              const status = document.getElementById('giveaway-activity-status'); if (status) status.textContent = `Last fetch: ${new Date().toLocaleTimeString()}`;
              const tokenEl = document.getElementById('giveaway-activity-token'); if (tokenEl) tokenEl.textContent = '#' + Math.random().toString(36).slice(2, 9);

              const inner = document.getElementById('giveaway-activity-inner');
              let _preservedTestNodes = [];
              if (inner) {
                try { _preservedTestNodes = Array.from(inner.querySelectorAll('[data-test="1"]')); } catch (e) { }
                // do not clear yet - we'll only replace if there are changes
              }

              const mkGsig = (arr) => (arr || []).map(g => (g.id || g.giveawayId || ('g-' + (g.ts || ''))) + '|' + (g.endsAt || g.ends_at || g.ts || '')).sort().join('||');
              const mkAsig = (arr) => (arr || []).slice(0, 40).map(a => (a.ts || (a.payload && JSON.stringify(a.payload)) || JSON.stringify(a))).join('||');
              const newGsig = mkGsig(giveaways);
              const newAsig = mkAsig(activities);
              const lastGsig = modalEl._lastGiveawaySignature || '';
              const lastAsig = modalEl._lastActivitySignature || '';

              // If nothing changed, update status and token and skip a DOM rebuild
              if (newGsig === lastGsig && newAsig === lastAsig) {
                // Only skip if the inner panel already contains visible items; if it's empty (e.g., first open), rebuild so historical activity appears
                const innerContentExists = (function () { try { if (!inner) return false; if (inner.querySelector && inner.querySelector('.giveaway-item')) return true; if (inner.querySelector && inner.querySelector('hr')) return true; if (inner.querySelector && inner.querySelector('[data-test="1"]')) return true; return false; } catch (e) { return false; } })();
                if (innerContentExists) {
                  if (status) status.textContent = `Last fetch: ${new Date().toLocaleTimeString()} (no changes)`;
                  console.log('refreshGiveawayActivity: no changes, skipping DOM update');
                  modalEl._lastGiveawaySignature = newGsig;
                  modalEl._lastActivitySignature = newAsig;
                  return;
                }
                // if no content present, fall through and rebuild the UI so historical activity is displayed
                console.log('refreshGiveawayActivity: no changes detected but panel empty ‚Äî rebuilding to show historical activity');
              }

              // detect starts/ends for small toasts/notifications
              const oldIds = modalEl._cachedGiveawayIds || [];
              const newIds = giveaways.map(g => g.id || g.giveawayId || ('g-' + (g.ts || '')));
              const started = newIds.filter(id => !oldIds.includes(id));
              const ended = oldIds.filter(id => !newIds.includes(id));
              // Auto-open Activity panel on new or ended giveaways and keep a reference for highlighting
              try { if (started.length || ended.length) { try { if (typeof setActiveSection === 'function') setActiveSection('activity'); } catch (e) { } modalEl._lastStartedIds = started; modalEl._lastEndedIds = ended; } } catch (e) { }
              if (started.length) { try { started.forEach(id => showToast('New giveaway started: ' + id, 'info')); } catch (e) { } }
              if (ended.length) { try { ended.forEach(id => showToast('Giveaway ended: ' + id, 'info')); } catch (e) { } }

              // proceed to clear the inner area and rebuild the UI
              if (inner) inner.innerHTML = '';
            } catch (e) { console.warn('Failed to log sample activity or compute signatures', e); }

            // Running Giveaways (from bot) ‚Äî render using forceRenderActivity for reliability
            try {
              if (typeof window.forceRenderActivity === 'function') {
                try { window.forceRenderActivity(giveaways, activities); } catch (e) { console.warn('forceRenderActivity failed', e); }
              } else {
                if (inner) inner.innerHTML = '<p class="small-muted">No activity renderer available</p>';
              }
            } catch (e) { console.warn('Failed to render running giveaways', e); }

            // Highlight newly started or recently ended giveaways briefly so they stand out
            try {
              const startedIds = modalEl._lastStartedIds || [];
              const endedIds = modalEl._lastEndedIds || [];
              if ((startedIds && startedIds.length) || (endedIds && endedIds.length)) {
                startedIds.forEach(id => { try { const c = inner.querySelector(`.giveaway-item[data-gid="${id}"]`); if (c) { c.classList.add('recent-start'); } } catch (e) { } });
                endedIds.forEach(id => { try { const c = inner.querySelector(`.giveaway-item[data-gid="${id}"]`); if (c) { c.classList.add('recent-end'); } } catch (e) { } });
                // clear highlight after a short while
                setTimeout(() => { try { startedIds.forEach(id => { const c = inner.querySelector(`.giveaway-item[data-gid="${id}"]`); if (c) c.classList.remove('recent-start'); }); endedIds.forEach(id => { const c = inner.querySelector(`.giveaway-item[data-gid="${id}"]`); if (c) c.classList.remove('recent-end'); }); } catch (e) { } }, 6500);
              }
            } catch (e) { console.warn('Failed to highlight recent giveaways', e); }

            // If we expected items but nothing rendered, show raw JSON so it's visible
            try {
              const hasItems = inner.querySelector('.giveaway-item');
              if (!hasItems && (giveaways.length > 0 || activities.length > 0)) {
                const fallback = document.createElement('pre'); fallback.style.whiteSpace = 'pre-wrap'; fallback.style.fontSize = '0.8rem'; fallback.style.marginTop = '8px'; fallback.style.color = 'var(--muted)'; fallback.id = 'giveaway-activity-fallback-json'; fallback.textContent = 'Render fallback:\nGIVEAWAYS:\n' + JSON.stringify(giveaways, null, 2).slice(0, 2000) + '\n\nACTIVITIES:\n' + JSON.stringify(activities, null, 2).slice(0, 2000);
                inner.appendChild(fallback);
              }
            } catch (e) { }

            // cache signatures and lists for the next diff
            try { modalEl._lastGiveawaySignature = (typeof newGsig !== 'undefined') ? newGsig : modalEl._lastGiveawaySignature; modalEl._lastActivitySignature = (typeof newAsig !== 'undefined') ? newAsig : modalEl._lastActivitySignature; modalEl._cachedGiveawayIds = giveaways.map(g => g.id || g.giveawayId || ('g-' + (g.ts || ''))); } catch (e) { }

            // expose the modal renderer under a stable name so the global fallback can call it without recursion
            try { if (typeof window.refreshGiveawayActivity === 'function') window._modalRefreshGiveawayActivity = window.refreshGiveawayActivity; } catch (e) { }
            el.querySelectorAll('.copy-id').forEach(b => b.onclick = () => { navigator.clipboard && navigator.clipboard.writeText(b.dataset.id); showToast('Copied giveaway ID', 'info'); });
            el.querySelectorAll('.view-winners').forEach(b => b.onclick = async () => {
              const gid = b.dataset.id;
              try {
                const out = await window.fetchGiveawayWinners(gid, { tries: 3, delayMs: 700 });
                if (out && out.winners && out.winners.length) {
                  try { const r = await fetch(`/api/giveaway-winners-resolve/${encodeURIComponent(serverId)}/${encodeURIComponent(gid)}`, { credentials: 'include' }); if (r && r.ok) { const jb = await r.json().catch(() => null); if (jb && Array.isArray(jb.resolved) && jb.resolved.length) { window.safeShowWinnersModal(gid, jb.resolved); return; } } } catch (e) { }
                  window.safeShowWinnersModal(gid, out.winners); return;
                }
                try { if (typeof showToast === 'function') showToast('No winners found yet. We retried contacting the bot and scanned recent activity. If you were the winner, try again in a few seconds.', 'info'); } catch (e) { console.info('No winners found yet'); }
              } catch (e) { console.warn('Failed to fetch winners', e); try { if (typeof showToast === 'function') showToast('Failed to fetch winners: ' + String(e), 'error'); } catch (e) { console.warn(e); } }
            });
            el.querySelectorAll('.reroll-giveaway').forEach(b => b.onclick = async () => {
              const gid = b.dataset.id; const resultEl = document.getElementById('giveaway-reroll-result'); if (resultEl) resultEl.textContent = '';
              try {
                const r = await fetch(`/api/server-giveaway-reroll/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ giveawayId: gid }) });
                if (r.ok) {
                  const jb = await r.json(); showToast('Reroll requested', 'info'); if (resultEl) resultEl.textContent = jb && jb.result ? String(jb.result) : 'Reroll requested'; // refresh list briefly
                  setTimeout(() => setActiveSection('activity'), 800); return;
                }
                if (r.status === 401) { if (resultEl) resultEl.textContent = 'Not authenticated'; showToast('Not authenticated', 'error'); return; }
                const txt = await r.text().catch(() => null); if (resultEl) resultEl.textContent = `Failed: ${r.status} ${txt || ''}`; showToast('Reroll failed', 'error');
              } catch (e) { console.error('Reroll failed', e); if (resultEl) resultEl.textContent = 'Reroll request failed'; showToast('Reroll failed', 'error'); }
            });
            modalEl._giveawayActivityTimer = setInterval(() => {
              const now = Date.now();
              el.querySelectorAll('.giveaway-remaining').forEach(span => {
                const endsTs = span.dataset.ends ? Number(span.dataset.ends) : null;
                if (!endsTs) { span.textContent = '‚Äî'; const dot = span.closest('.giveaway-item').querySelector('div[style*="border-radius:999px"]'); if (dot) dot.style.background = 'var(--muted)'; return; }
                const remainMs = endsTs - now;
                span.textContent = remainMs > 0 ? fmtRemaining(remainMs) : 'Ended';
                const dot = span.closest('.giveaway-item').querySelector('.dot'); if (dot) { if (remainMs > 0) dot.style.background = '#3ad37f'; else dot.style.background = 'var(--danger)'; }
              });
            }, 1000);

            // short poll to refresh the active section regularly (keeps listing updated)
            modalEl._giveawayActivityPoll = setInterval(() => { if (typeof setActiveSection === 'function') setActiveSection('activity'); }, 8000);

            // Auto-refresh the activity list every REFRESH_MS milliseconds while the modal is open
            // Default is 15s (15000). Change this value to anything between 10000 and 30000 to meet your preference.
            const REFRESH_MS = 15000; // 15 seconds
            modalEl._giveawayAutoRefresh = setInterval(() => {
              try {
                if (modalEl && modalEl.getAttribute && modalEl.getAttribute('aria-hidden') === 'false') {
                  if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity();
                }
              } catch (e) { /* ignore */ }
            }, REFRESH_MS);
            return;
          } catch (e) { console.warn('Failed to load activity/giveaways', e); try { const status = document.getElementById('giveaway-activity-status'); if (status) status.textContent = 'Failed to fetch'; } catch (e) { } }
          el.innerHTML = '<p class="small-muted">Failed to load giveaway activity.</p>';
        };


        // captured pointerdown handler on the modal side to ensure we observe low-level events
        const sideCaptured = modal.querySelector('.modal-side');
        if (sideCaptured) {
          sideCaptured.addEventListener('pointerdown', (ev) => {
            try {
              const btn = ev.target.closest('.panel-option');
              console.log('pointerdown on side:', btn ? btn.dataset.section : ev.target && (ev.target.tagName || ev.target.className));
              if (btn) { ev.preventDefault(); ev.stopPropagation(); setActiveSection(btn.dataset.section); }
            } catch (e) { console.warn('pointerdown handler error', e); }
          }, { capture: true });

          // pointerup coordinate mapping fallback (catches clicks even if target events are swallowed)
          document.addEventListener('pointerup', (ev) => {
            try {
              const modalNow = document.getElementById('plugin-modal-giveaway'); if (!modalNow || modalNow.getAttribute('aria-hidden') === 'true') return;
              const sideRect = sideCaptured.getBoundingClientRect(); if (ev.clientX < sideRect.left || ev.clientX > sideRect.right || ev.clientY < sideRect.top || ev.clientY > sideRect.bottom) return;

              // find which panel-option contains the coordinates
              const opts = Array.from(sideCaptured.querySelectorAll('.panel-option'));
              for (const opt of opts) { const r = opt.getBoundingClientRect(); if (ev.clientX >= r.left && ev.clientX <= r.right && ev.clientY >= r.top && ev.clientY <= r.bottom) { console.log('pointerup mapped to option', opt.dataset.section); try { if (typeof showToast === 'function') showToast('Opening ' + opt.dataset.section, 'info'); } catch (e) { } setActiveSection(opt.dataset.section); break; } }
            } catch (e) { console.warn('pointerup mapper error', e); }
          }, { capture: true });
        }

        // Global delegated handler for "Fetch now" to work even if the element was re-rendered or not yet wired
        // Fetch-now delegated handler removed (manual fetch button disabled)


        // Robust wrapper that shows button feedback and always attempts the refresh
        window.tryRefreshGiveawayActivity = async function () {
          const btn = document.getElementById('giveaway-activity-fetch-now');
          try {
            console.log('tryRefreshGiveawayActivity invoked');
            if (btn) { btn.disabled = true; btn._origText = btn._origText || btn.textContent || 'Fetch now'; btn.textContent = 'Fetching‚Ä¶'; }
            if (typeof window.refreshGiveawayActivity === 'function') {
              try { await window.refreshGiveawayActivity(); }
              catch (e) { console.warn('refreshGiveawayActivity threw', e); try { const status = document.getElementById('giveaway-activity-status'); if (status) status.textContent = 'Failed to fetch'; } catch (e) { } }
            } else { console.warn('refreshGiveawayActivity not available'); try { const status = document.getElementById('giveaway-activity-status'); if (status) status.textContent = 'Not available'; } catch (e) { } }
          } finally {
            setTimeout(() => { try { if (btn) { btn.disabled = false; btn.textContent = btn._origText || 'Fetch now'; } } catch (e) { } }, 600);
          }
        };

        // Extra listener: pointerdown/click mapping to call the robust wrapper (some environments swallow click events)
        // Fetch-now pointerdown mapper removed (manual fetch button disabled)


        // default to defaults section
        setActiveSection('defaults');

        // ensure accessibility: focus first control inside the active section when it changes
        const _origSetActive = setActiveSection;
        setActiveSection = async function (s) {
          await _origSetActive(s);
          try {
            const visible = modal.querySelector(`.section-block[data-section="${s}"]`);
            if (visible) { const first = visible.querySelector('input,textarea,button'); if (first) first.focus(); }
          } catch (e) { /* ignore */ }
        };


        // Test button
        const giveawayTestBtn = document.getElementById('giveaway-modal-test');
        if (giveawayTestBtn) {
          giveawayTestBtn.onclick = async () => {
            if (statusElem) statusElem.textContent = 'Sending giveaway test‚Ä¶';
            showToast('Sending giveaway test‚Ä¶', 'info');
            try {
              // include current form values (minutes + seconds) for a more accurate test
              const m = minInput ? Number(minInput.value) || 0 : 0;
              const s = secInput ? Number(secInput.value) || 0 : 0;
              const durationVal = Math.max(0, m + (s / 60));
              const data = { giveaway: { duration: durationVal, channel: (ch ? (ch.value ? ch.value.trim() : '') : ''), prize: (prize ? (prize.value ? prize.value.trim() : '') : ''), mention: (mention ? !!mention.checked : true) } };
              const res = await fetch(`/api/server-plugin-test/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: id, testType: 'giveaway', config: data }) });
              if (res.ok) {
                showToast('Test request sent to bot', 'info'); if (statusElem) statusElem.textContent = 'Test request sent to bot';
                // try to parse response - bot may return the created giveaway
                let created = null;
                try { const jb = await res.clone().json().catch(() => null); if (jb) { if (jb.giveaway) created = jb.giveaway; else if (Array.isArray(jb.giveaways) && jb.giveaways.length) created = jb.giveaways[0]; else if (jb.result && jb.result.giveaway) created = jb.result.giveaway; else if (jb.id) created = { id: jb.id, prize: data.giveaway.prize, createdAt: new Date().toISOString(), endsAt: new Date(Date.now() + (data.giveaway.duration || 0) * 60 * 1000).toISOString(), channel: { id: data.giveaway.channel } }; } } catch (e) { console.warn('Failed to parse test response', e); }
                if (created && typeof window.addImmediateGiveawayToActivity === 'function') { try { created._isTest = true; window.addImmediateGiveawayToActivity(created); } catch (e) { console.warn('failed to add immediate giveaway', e); } }
                // Also synthesize a lightweight plugin_test activity so the Recent Activity shows the test immediately
                try {
                  const activityEntry = { type: 'plugin_test', pluginId: id, payload: { testType: 'giveaway', config: data }, user: { username: 'You' }, ts: Date.now() };
                  activityEntry._isTest = true;
                  if (typeof window.addImmediateActivityEntry === 'function') { try { window.addImmediateActivityEntry(activityEntry); } catch (e) { console.warn('failed to add immediate activity', e); } }
                } catch (e) { console.warn('failed to synthesize immediate activity', e); }
                // refresh activity tab shortly so test-created giveaways appear
                try { if (typeof showToast === 'function') showToast('Refreshing activity‚Ä¶', 'info'); } catch (e) { }
                // aggressive short polling to surface the newly created giveaway quickly
                try { if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                let tries = 0; const poller = setInterval(() => {
                  try { if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }
                  tries++; if (tries > 12) clearInterval(poller);
                }, 1000);
                setTimeout(() => { try { clearInterval(poller); if (typeof setActiveSection === 'function') setActiveSection('activity'); else if (typeof window.dashboardSetGiveawaySection === 'function') window.dashboardSetGiveawaySection('activity'); } catch (e) { } }, 1200);
                return;
              }
              if (res.status === 401) { showToast('Not authenticated; cannot send test', 'error'); if (statusElem) statusElem.textContent = 'Test failed: not authenticated'; }
            } catch (e) { showToast('Failed to send test', 'error'); if (statusElem) statusElem.textContent = 'Failed to send test'; }
          };
        }

        if (saveBtn) {
          // if not authenticated, prompt user to sign in before saving to server
          if (!serverAuth) { if (statusElem) statusElem.innerHTML = 'Not signed in ‚Äî <a href="/auth">Sign in</a> to save to server and notify the bot.'; showToast('Not signed in ‚Äî saving locally only', 'info'); }

          // bind with a named handler so repeated openings don't rebind
          if (saveBtn._giveawayHandler) saveBtn.removeEventListener('click', saveBtn._giveawayHandler);
          const saveHandler = async (ev) => {
            if (statusElem) statusElem.textContent = '';
            try {
              console.log('Giveaway save handler invoked');
              saveBtn.disabled = true; const prevText = saveBtn.textContent; saveBtn.textContent = 'Saving...';
              // combine minutes + seconds into minutes (float)
              const m = minInput ? (Number(minInput.value) || 0) : 0;
              const s = secInput ? (Number(secInput.value) || 0) : 0;
              const durationVal = Math.max(0, m + (s / 60));
              const data = { giveaway: { duration: durationVal, channel: (ch ? (ch.value ? ch.value.trim() : '') : ''), prize: (prize ? (prize.value ? prize.value.trim() : '') : ''), mention: (mention ? !!mention.checked : true) } };
              console.log('Saving giveaway config', data);
              // Resolve channel for clarity before saving
              if (data.giveaway && data.giveaway.channel) {
                try {
                  const rc = await fetch(`/api/guild-channel/${encodeURIComponent(serverId)}/${encodeURIComponent(data.giveaway.channel)}`);
                  if (rc.ok) { const j = await rc.json(); if (j && j.channel) { if (statusElem) statusElem.textContent = `Channel: ${j.channel.name ? '#' + j.channel.name : j.channel.mention}`; console.log('Resolved channel to', j.channel); } }
                  else { console.warn('Channel resolve returned', rc.status); if (statusElem) statusElem.textContent = 'Channel could not be resolved'; }
                } catch (e) { console.warn('Channel resolve failed', e); if (statusElem) statusElem.textContent = 'Channel resolve failed'; }
              }
              if (serverAuth) {
                try {
                  const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: id, config: data }) });
                  if (res.ok) {
                    showToast('Saved giveaway settings to server', 'info'); if (statusElem) statusElem.textContent = 'Saved to server';
                    // also send a test request to bot to create giveaway now using this config
                    try {
                      const tRes = await fetch(`/api/server-plugin-test/${encodeURIComponent(serverId)}`, {
                        method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pluginId: id, testType: 'giveaway', config: data })
                      });
                      if (tRes && tRes.ok) {
                        showToast('Test created on bot', 'info');
                        if (statusElem) statusElem.textContent = 'Saved to server; test created on bot';

                        // try to parse created giveaway returned by bot
                        let created = null;
                        try {
                          const tb = await tRes.clone().json().catch(() => null);
                          if (tb) {
                            if (tb.giveaway) created = tb.giveaway;
                            else if (Array.isArray(tb.giveaways) && tb.giveaways.length) created = tb.giveaways[0];
                            else if (tb.result && tb.result.giveaway) created = tb.result.giveaway;

                            if (created && typeof window.addImmediateGiveawayToActivity === 'function') {
                              try { created._isTest = true; window.addImmediateGiveawayToActivity(created); } catch (e) { console.warn('failed to add immediate giveaway from saveHandler', e); }
                            }

                            // also add a lightweight activity entry
                            const activityEntry = { type: 'plugin_test', pluginId: id, payload: { testType: 'giveaway', config: data }, user: { username: 'You' }, ts: Date.now() };
                            activityEntry._isTest = true;
                            if (typeof window.addImmediateActivityEntry === 'function') {
                              try { window.addImmediateActivityEntry(activityEntry); } catch (e) { console.warn('failed to add immediate activity from saveHandler', e); }
                            }
                          }
                        } catch (e) {
                          console.warn('Failed to parse test response', e);
                        }

                        try { if (typeof showToast === 'function') showToast('Refreshing activity‚Ä¶', 'info'); } catch (e) { }

                        // Switch to activity panel and aggressively poll a few times so the new giveaway is surfaced
                        const openActivityAndPoll = () => {
                          // aggressive short polling to surface the newly created giveaway quickly
                          let tries = 0;
                          const maxTries = 12;

                          // indicate activity tab has new content without switching sections
                          try {
                            const activityBtn = modal.querySelector('.panel-option[data-section="activity"]');
                            if (activityBtn) { activityBtn.classList.add('has-new'); }
                            try { if (typeof showToast === 'function') showToast('New giveaway created ‚Äî Activity tab is refreshing in background', 'info'); } catch (e) { }
                          } catch (e) { }

                          const poller = setInterval(async () => {
                            try { if (typeof window.refreshGiveawayActivity === 'function') await window.refreshGiveawayActivity(); } catch (e) { }
                            tries++; if (tries >= maxTries) { clearInterval(poller); try { const activityBtn = modal.querySelector('.panel-option[data-section="activity"]'); if (activityBtn) { activityBtn.classList.remove('has-new'); } } catch (e) { } }
                          }, 1000);
                          // one immediate refresh
                          try { if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { }

                          // If we did not get a created giveaway back from the bot, try to keep modal open and let the auto-refresh handle it
                          if (!created) { /* nothing extra to do */ }
                        };

                        // Keep modal open and show activity
                        openActivityAndPoll();

                        // Do NOT close the modal if we created a giveaway - let the user stay and see it live
                        if (!created) { // no created giveaway in response, fallback to closing modal
                          try { setTimeout(() => { const m = document.getElementById('plugin-modal-giveaway'); if (m) { m.setAttribute('aria-hidden', 'true'); setTimeout(() => { m.style.display = 'none'; }, 220); } }, 1200); } catch (e) { }
                        }

                        // return without closing modal if created; otherwise we already scheduled the close above
                        return;
                      } else {
                        console.warn('Test request returned', tRes && tRes.status);
                        if (statusElem) statusElem.textContent = 'Saved to server; test request failed';
                      }
                    } catch (e) {
                      console.warn('Failed to send test request', e);
                      if (statusElem) statusElem.textContent = 'Saved to server; test request failed';
                    }
                    // If we reach here we failed to create a test or did not see a test that returns a giveaway - close modal as before
                    closeGiveawayConfig(); return;
                  }
                  if (res.status === 401) { serverAuth = false; showToast('Not authenticated; saved locally', 'error'); if (statusElem) statusElem.textContent = 'Not authenticated; saved locally'; }
                } catch (e) { console.error('Failed to save to server', e); showToast('Failed to save to server; saved locally', 'error'); if (statusElem) statusElem.textContent = 'Failed to save to server; saved locally'; }
              }
              // local fallback
              try { localStorage.setItem(`ng_plugin_config_${serverId}_${id}`, JSON.stringify(data)); if (!savedToServer) showToast('Saved locally', 'info'); if (statusElem && !savedToServer) statusElem.textContent = 'Saved locally'; closeGiveawayConfig(); } catch (e) { console.error('Failed to save locally', e); showToast('Failed to save settings', 'error'); if (statusElem) statusElem.textContent = 'Failed to save settings'; }
            } catch (e) { console.error('Unexpected error saving giveaway config', e); showToast('Error saving giveaway settings', 'error'); if (statusElem) statusElem.textContent = 'Error saving giveaway settings'; }
            finally { saveBtn.disabled = false; try { saveBtn.textContent = 'Save'; } catch (e) { } }
          };
          saveBtn._giveawayHandler = saveHandler; saveBtn.addEventListener('click', saveHandler);
        }
      };

      // Global fallback: allow inline onclick to switch giveaway panel sections even if event wiring fails
      window.dashboardSetGiveawaySection = function (s) {
        try {
          const modal = document.getElementById('plugin-modal-giveaway'); if (!modal) return;
          modal.querySelectorAll('.section-block').forEach(sb => { sb.style.display = (sb.dataset.section === s) ? 'block' : 'none'; });
          modal.querySelectorAll('.panel-option').forEach(b => b.classList.toggle('active', b.dataset.section === s));
          const visible = modal.querySelector(`.section-block[data-section="${s}"]`);
          if (visible) { const first = visible.querySelector('input,textarea,button'); if (first) first.focus(); }
          if (typeof showToast === 'function') showToast('Opened ' + s, 'info');
          // If opening Activity section via this fallback, ensure we refresh the activity list
          if (s === 'activity') { try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); } catch (e) { } }
        } catch (e) { console.warn('dashboardSetGiveawaySection error', e); }
      };

      // Reset/test handlers for welcome
      (function () {
        const resetBtn = document.getElementById('welcome-modal-reset');
        const welcomeTestBtn = document.getElementById('welcome-modal-test');
        if (resetBtn) {
          resetBtn.onclick = async () => {
            const ok = (typeof window.showConfirm === 'function') ? await window.showConfirm('Reset Welcome & Bye settings to defaults? This will clear any custom messages.', 'Reset Welcome/Bye') : confirm('Reset Welcome & Bye settings to defaults?');
            if (!ok) return;
            const pluginConfig = { welcome: { channel: '', message: null }, bye: { channel: '', message: null } };
            if (serverAuth) { try { const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: 'welcome', config: pluginConfig }) }); if (res.ok) { showToast('Reset settings on server', 'info'); const wCh = document.getElementById('welcome-modal-welcome-channel'), wMsg = document.getElementById('welcome-modal-welcome-message'), bCh = document.getElementById('welcome-modal-bye-channel'), bMsg = document.getElementById('welcome-modal-bye-message'); if (wCh) wCh.value = ''; if (wMsg) wMsg.value = 'Welcome {user} to our server!'; if (bCh) bCh.value = ''; if (bMsg) bMsg.value = 'Goodbye {user}!'; return; } if (res.status === 401) { serverAuth = false; showToast('Not authenticated; reset locally', 'error'); } } catch (e) { showToast('Failed to reset on server; reset locally', 'error'); } }
            // local reset
            try { const raw = localStorage.getItem(`ng_plugin_config_${serverId}_welcome`); let obj = { welcome: { channel: '', message: 'Welcome {user} to our server!' }, bye: { channel: '', message: 'Goodbye {user}!' } }; try { if (raw) obj = JSON.parse(raw); } catch (e) { } obj.welcome.channel = ''; obj.welcome.message = null; obj.bye.channel = ''; obj.bye.message = null; localStorage.setItem(`ng_plugin_config_${serverId}_welcome`, JSON.stringify(obj)); const wCh = document.getElementById('welcome-modal-welcome-channel'), wMsg = document.getElementById('welcome-modal-welcome-message'), bCh = document.getElementById('welcome-modal-bye-channel'), bMsg = document.getElementById('welcome-modal-bye-message'); if (wCh) wCh.value = ''; if (wMsg) wMsg.value = 'Welcome {user} to our server!'; if (bCh) bCh.value = ''; if (bMsg) bMsg.value = 'Goodbye {user}!'; showToast('Reset locally', 'info'); } catch (e) { showToast('Failed to reset', 'error'); }
          };
        }

        if (welcomeTestBtn) {
          welcomeTestBtn.onclick = async () => {
            showToast('Sending welcome test‚Ä¶', 'info');
            try { const res = await fetch(`/api/server-plugin-test/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: 'welcome', testType: 'welcome' }) }); if (res.ok) { showToast('Test sent to bot', 'info'); return; } if (res.status === 401) showToast('Not authenticated; cannot send test', 'error'); } catch (e) { showToast('Failed to send test', 'error'); }
          };
        }
      })();

      // Reset handlers for giveaway
      (function () {
        const resetBtn = document.getElementById('giveaway-modal-reset');
        if (resetBtn) {
          resetBtn.onclick = async () => {
            const ok = (typeof window.showConfirm === 'function') ? await window.showConfirm('Reset Giveaway defaults to original values?', 'Reset Giveaway') : confirm('Reset Giveaway defaults to original values?');
            if (!ok) return;
            const pluginConfig = { giveaway: { duration: 60, channel: '', prize: null, mention: true } };
            if (serverAuth) { try { const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: 'giveaway', config: pluginConfig }) }); if (res.ok) { showToast('Reset giveaway defaults on server', 'info'); const min = document.getElementById('giveaway-modal-duration-min'), sec = document.getElementById('giveaway-modal-duration-sec'), ch = document.getElementById('giveaway-modal-channel'), pr = document.getElementById('giveaway-modal-prize'), mn = document.getElementById('giveaway-modal-mention'); if (min) min.value = '60'; if (sec) sec.value = '0'; if (ch) ch.value = ''; if (pr) pr.value = ''; if (mn) mn.checked = true; return; } if (res.status === 401) { serverAuth = false; showToast('Not authenticated; reset locally', 'error'); } } catch (e) { showToast('Failed to reset on server; reset locally', 'error'); } }
            // local fallback
            try { const raw = localStorage.getItem(`ng_plugin_config_${serverId}_giveaway`); let obj = { giveaway: { duration: 60, channel: '', prize: '', mention: true } }; try { if (raw) obj = JSON.parse(raw); } catch (e) { } obj.giveaway.duration = 60; obj.giveaway.channel = ''; obj.giveaway.prize = ''; obj.giveaway.mention = true; localStorage.setItem(`ng_plugin_config_${serverId}_giveaway`, JSON.stringify(obj)); const min = document.getElementById('giveaway-modal-duration-min'), sec = document.getElementById('giveaway-modal-duration-sec'), ch = document.getElementById('giveaway-modal-channel'), pr = document.getElementById('giveaway-modal-prize'), mn = document.getElementById('giveaway-modal-mention'); if (min) min.value = '60'; if (sec) sec.value = '0'; if (ch) ch.value = ''; if (pr) pr.value = ''; if (mn) mn.checked = true; showToast('Reset locally', 'info'); } catch (e) { showToast('Failed to reset', 'error'); }
          };
        }

        // Reroll handler wiring
        const rerollBtn = document.getElementById('giveaway-reroll-btn');
        if (rerollBtn) {
          rerollBtn.addEventListener('click', async () => {
            const input = document.getElementById('giveaway-reroll-id'); const result = document.getElementById('giveaway-reroll-result'); if (result) result.textContent = '';
            const gid = input ? input.value.trim() : '';
            if (!gid) { if (result) result.textContent = 'Enter a giveaway ID to reroll'; return; }
            try {
              rerollBtn.disabled = true; const orig = rerollBtn.textContent; rerollBtn.textContent = 'Rerolling‚Ä¶';
              const res = await fetch(`/api/server-giveaway-reroll/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ giveawayId: gid }) });
              if (res.ok) { const body = await res.json(); if (result) result.textContent = body && body.result ? String(body.result) : 'Reroll requested'; showToast('Reroll requested', 'info'); try { rerollBtn.textContent = orig; rerollBtn.disabled = false; } catch (e) { } return; }
              if (res.status === 401) { if (result) result.textContent = 'Not authenticated'; showToast('Not authenticated', 'error'); try { rerollBtn.textContent = orig; rerollBtn.disabled = false; } catch (e) { } return; }
              // parse JSON error body if possible
              let body = null; try { body = await res.json(); } catch (e) { body = { text: await res.text().catch(() => null) }; }
              const reason = (body && (body.details && (body.details.suggestion || body.details.error || body.details.message))) || (body && (body.suggestion || body.error || body.message)) || (body && body.text) || 'Unknown';
              if (result) result.textContent = `Failed: ${res.status} ${reason}`; if (body && body.suggestion) { try { if (result) result.textContent += ' ‚Äî Suggestion: ' + body.suggestion; } catch (e) { } }
              try { if (typeof showToast === 'function') showToast('Reroll failed: ' + reason, 'error'); } catch (e) { }
              try { rerollBtn.textContent = orig; rerollBtn.disabled = false; } catch (e) { }
            } catch (e) { console.error('Reroll failed', e); if (result) result.textContent = 'Reroll request failed: ' + (e && e.message ? e.message : String(e)); showToast('Reroll failed', 'error'); try { rerollBtn.textContent = orig; rerollBtn.disabled = false; } catch (e) { } }
          });
        }
      })();

    };

    // Global helpers (fallbacks) so buttons work even if modal wiring didn't run
    window.saveGiveawayConfig = async function () {
      try {
        console.log('Global saveGiveawayConfig called');
        const statusElem = document.getElementById('giveaway-modal-status'); if (statusElem) statusElem.textContent = '';
        const ch = document.getElementById('giveaway-modal-channel'); const prize = document.getElementById('giveaway-modal-prize'); const mention = document.getElementById('giveaway-modal-mention');
        const min = Number(document.getElementById('giveaway-modal-duration-min')?.value || 0); const sec = Number(document.getElementById('giveaway-modal-duration-sec')?.value || 0); const durationVal = Math.max(0, min + (sec / 60));
        const data = { giveaway: { duration: durationVal, channel: (ch ? (ch.value ? ch.value.trim() : '') : ''), prize: (prize ? (prize.value ? prize.value.trim() : '') : ''), mention: (mention ? !!mention.checked : true) } };
        console.log('Global saving giveaway config', data);
        // try server save first
        let savedToServer = false;
        try {
          const res = await fetch(`/api/server-plugin-config/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: 'giveaway', config: data }) });
          if (res.ok) { savedToServer = true; showToast('Saved giveaway settings to server', 'info'); if (statusElem) statusElem.textContent = 'Saved to server'; }
          else if (res.status === 401) { showToast('Not authenticated; saved locally', 'error'); if (statusElem) statusElem.textContent = 'Not authenticated; saved locally'; }
          else { console.warn('Server save returned', res.status); if (statusElem) statusElem.textContent = 'Server save failed'; }
        } catch (e) { console.warn('Server save failed', e); if (statusElem) statusElem.textContent = 'Server save failed'; }

        // local fallback
        try { localStorage.setItem(`ng_plugin_config_${serverId}_giveaway`, JSON.stringify(data)); if (!savedToServer) showToast('Saved locally', 'info'); if (statusElem && !savedToServer) statusElem.textContent = 'Saved locally'; } catch (e) { console.error('Failed to save locally', e); if (statusElem) statusElem.textContent = 'Failed to save locally'; }

        // If saved to server, try to request bot create the giveaway immediately
        if (savedToServer) {
          try {
            const tRes = await fetch(`/api/server-plugin-test/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: 'giveaway', testType: 'giveaway', config: data }) });
            if (tRes && tRes.ok) { showToast('Test created on bot', 'info'); if (statusElem) statusElem.textContent = 'Saved to server; test created on bot'; }
            else { console.warn('Test request returned', tRes && tRes.status); if (statusElem) statusElem.textContent = 'Saved to server; test request failed'; }
          } catch (e) { console.warn('Failed to send test request', e); if (statusElem) statusElem.textContent = 'Saved to server; test request failed'; }
        }

        // close modal on success
        if (savedToServer || (!savedToServer && (localStorage.getItem(`ng_plugin_config_${serverId}_giveaway`) !== null))) { const m = document.getElementById('plugin-modal-giveaway'); if (m) { m.setAttribute('aria-hidden', 'true'); setTimeout(() => m.style.display = 'none', 220); } }
      } catch (e) { console.error('Unexpected error in saveGiveawayConfig', e); }
    };

    window.sendGiveawayTest = async function () {
      try {
        const statusElem = document.getElementById('giveaway-modal-status'); if (statusElem) statusElem.textContent = 'Sending giveaway test‚Ä¶';
        const ch = document.getElementById('giveaway-modal-channel'); const prize = document.getElementById('giveaway-modal-prize'); const mention = document.getElementById('giveaway-modal-mention');
        const min = Number(document.getElementById('giveaway-modal-duration-min')?.value || 0); const sec = Number(document.getElementById('giveaway-modal-duration-sec')?.value || 0); const durationVal = Math.max(0, min + (sec / 60));
        const data = { giveaway: { duration: durationVal, channel: (ch ? (ch.value ? ch.value.trim() : '') : ''), prize: (prize ? (prize.value ? prize.value.trim() : '') : ''), mention: (mention ? !!mention.checked : true) } };
        // attempt to resolve and show channel name for feedback
        if (data.giveaway && data.giveaway.channel) {
          try { const rc = await fetch(`/api/guild-channel/${encodeURIComponent(serverId)}/${encodeURIComponent(data.giveaway.channel)}`); if (rc.ok) { const j = await rc.json(); if (j && j.channel) { if (statusElem) statusElem.textContent = `Channel: ${j.channel.name ? '#' + j.channel.name : j.channel.mention}`; } } else { if (statusElem) statusElem.textContent = 'Channel could not be resolved'; } } catch (e) { console.warn('Channel resolve failed', e); if (statusElem) statusElem.textContent = 'Channel resolve failed'; }
        }
        const res = await fetch(`/api/server-plugin-test/${encodeURIComponent(serverId)}`, { method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pluginId: 'giveaway', testType: 'giveaway', config: data }) });
        if (res.ok) {
          showToast('Test request sent to bot', 'info'); if (statusElem) statusElem.textContent = 'Test request sent to bot';
          try {
            const activityEntry = { type: 'plugin_test', pluginId: 'giveaway', payload: { testType: 'giveaway', config: data }, user: { username: 'You' }, ts: Date.now() };
            activityEntry._isTest = true;
            if (typeof window.addImmediateActivityEntry === 'function') { try { window.addImmediateActivityEntry(activityEntry); } catch (e) { console.warn('failed to add immediate activity', e); } }
          } catch (e) { console.warn('failed to synthesize immediate activity', e); }
          try { if (typeof showToast === 'function') showToast('Refreshing activity‚Ä¶', 'info'); } catch (e) { }
          setTimeout(() => { try { if (typeof setActiveSection === 'function') setActiveSection('activity'); else if (typeof window.dashboardSetGiveawaySection === 'function') window.dashboardSetGiveawaySection('activity'); } catch (e) { } }, 1200);
        }
        else if (res.status === 401) { showToast('Not authenticated; cannot send test', 'error'); if (statusElem) statusElem.textContent = 'Not authenticated; cannot send test'; }
        else { showToast('Test request failed', 'error'); if (statusElem) statusElem.textContent = 'Test request failed'; }
      } catch (e) { console.error('Failed to send giveaway test', e); if (document.getElementById('giveaway-modal-status')) document.getElementById('giveaway-modal-status').textContent = 'Failed to send test'; }
    };

    window.closePluginConfig = function () { const modal = document.getElementById('plugin-modal'); if (!modal) return; modal.setAttribute('aria-hidden', 'true'); setTimeout(() => { modal.style.display = 'none'; }, 220); };

    // refresh activity and members when rendering plugins

    // Attach an observer so showing the Giveaway modal automatically refreshes the Activity list
    try {
      (function attachGiveawayModalObserver() {
        try {
          const attach = () => {
            const modal = document.getElementById('plugin-modal-giveaway'); if (!modal) return;
            if (modal._giveawayShowObserver) return;
            const obs = new MutationObserver(muts => {
              try {
                for (const m of muts) {
                  if (m.attributeName === 'aria-hidden') {
                    const v = modal.getAttribute('aria-hidden');
                    if (v === 'false') {
                      setTimeout(() => { try { if (typeof window.tryRefreshGiveawayActivity === 'function') window.tryRefreshGiveawayActivity(); else if (typeof window.refreshGiveawayActivity === 'function') window.refreshGiveawayActivity(); } catch (e) { } }, 40);
                    }
                  }
                }
              } catch (e) { }
            });
            obs.observe(modal, { attributes: true, attributeFilter: ['aria-hidden'] });
            modal._giveawayShowObserver = obs;
          };
          attach();
          // retry shortly in case modal is created later
          setTimeout(attach, 200);
          // watch for late DOM insertions
          const bodyObs = new MutationObserver(() => { attach(); });
          bodyObs.observe(document.body, { childList: true, subtree: true });
        } catch (e) { console.warn('attachGiveawayModalObserver failed', e); }
      })();
    } catch (e) { }

    loadActivityFeed();
    loadMembers();

    // Ensure a persistent debug button exists so you can trigger activity refresh manually
    // Removed persistent debug test button; refresh now happens automatically on modal show/panel switch


    async function loadActivityFeed() {
      const feed = document.getElementById('activity-feed'); if (!feed) return;
      // only show loading on very first load
      if (feed.innerHTML === '') feed.innerHTML = '<p class="small-muted">Loading activity‚Ä¶</p>';

      try {
        const res = await fetch(`/api/server-activity/${encodeURIComponent(serverId)}`);
        if (res.ok) {
          const body = await res.json(); const arr = body.activity || [];
          if (arr.length === 0) { feed.innerHTML = '<p class="small-muted">No recent activity for this server.</p>'; return; }

          let html = '';
          arr.slice(0, 30).forEach(a => {
            const d = new Date(a.ts || Date.now());
            const who = a.user ? (a.user.username) : 'System';
            const pluginLabel = a.pluginId ? (a.pluginId.charAt(0).toUpperCase() + a.pluginId.slice(1)) : 'System';

            // Determine state carefully
            const isEnabled = a.enabled === true;
            const actionText = a.type === 'plugin_update' ? (isEnabled ? 'enabled' : 'disabled') : (a.description || a.type);
            const dotColor = (a.type === 'plugin_update') ? (isEnabled ? 'var(--accent)' : 'var(--danger)') : 'var(--accent)';

            html += `
              <div class="activity-item" style="margin-bottom:12px;display:flex;gap:12px;align-items:center">
                <div style="width:10px;height:10px;border-radius:999px;background:${dotColor};flex-shrink:0"></div>
                <div style="flex:1">
                  <strong>${pluginLabel}</strong> ${actionText}
                  <div class="small-muted" style="font-size:0.8rem">by ${who} ¬∑ ${d.toLocaleString()}</div>
                </div>
              </div>`;
          });
          feed.innerHTML = html;
          return;
        }
      } catch (e) { console.warn('Failed to load activity', e); }
      if (feed.innerHTML === '') feed.innerHTML = '<p class="small-muted">Failed to load activity.</p>';
    }

    // Live Activity Feed Polling
    let _activityPoll = setInterval(loadActivityFeed, 10000);

    async function loadMembers() {
      const list = document.getElementById('members-list'); if (!list) return;
      list.innerHTML = '<p class="small-muted">Loading members‚Ä¶</p>';
      try {
        const res = await fetch(`/api/guild-members/${encodeURIComponent(serverId)}?limit=30`);
        if (res.ok) {
          const body = await res.json(); const members = body.members || [];
          if (members.length === 0) { list.innerHTML = '<p class="small-muted">No members found or bot not present in this guild.</p>'; return; }
          list.innerHTML = '';
          const listContainer = document.createElement('div'); listContainer.className = 'member-list';

          // Fetch presences from server proxy
          // We wait just a moment (150ms) to let the Bot's fetch (triggered by the concurrent guild-members call) populate its cache
          await new Promise(r => setTimeout(r, 150));
          let presenceMap = {};
          try {
            const pRes = await fetch(`/api/guild-presences/${encodeURIComponent(serverId)}`);
            if (pRes.ok) {
              const pBody = await pRes.json();
              const presences = pBody.presences || [];
              presences.forEach(p => {
                if (p && p.id) {
                  // status can be in p.status (directly from bot) or p.presence (nested)
                  const s = (p.status || (p.presence && p.presence.status) || 'unknown').toLowerCase();
                  presenceMap[p.id] = s;
                }
              });
              console.log('[Dashboard] Received presences count:', Object.keys(presenceMap).length);
            }
          } catch (e) {
            console.warn('Failed to fetch presences', e);
          }

          if (Object.keys(presenceMap).length === 0) {
            console.log('[Dashboard] No live statuses found. Check if Bot is online and BOT_PRESENCE_URL is correct.');
          }

          members.forEach(m => {
            const item = document.createElement('div'); item.className = 'member-item';
            const avatar = m.avatar ? discordAvatarUrl(m.id, m.avatar, 64) : 'https://cdn.jsdelivr.net/gh/identicons/identicon.png';
            const status = (presenceMap[m.id] || m.status || m.presence || 'unknown').toLowerCase();
            item.innerHTML = `
            <div style="display:flex;gap:12px;align-items:center;width:100%">
              <div class="avatar-wrap" style="position:relative;flex:0 0 48px">
                <img src="${avatar}" alt="${m.username}" class="member-avatar" data-member-id="${m.id}">
                <span class="status-dot status-${status}" data-member-id="${m.id}" title="Status: ${status}"></span>
              </div>
              <div style="flex:1;min-width:0">
                <strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${m.username}</strong>
                <div class="small-muted" style="font-size:0.85rem;margin-top:4px">ID: ${m.id}</div>
              </div>
            </div>`;
            listContainer.appendChild(item);
          });
          list.appendChild(listContainer);
          // ensure images have fallback if available
          try { if (typeof attachImageFallbacks === 'function') attachImageFallbacks(list); } catch (e) { console.warn('attachImageFallbacks not available', e); }
          return;
        } else {
          const text = await res.text().catch(() => null);
          console.warn('Members fetch returned', res.status, text);
          list.innerHTML = `<p class="small-muted">Failed to load members (status ${res.status}). ${text ? 'See console for details.' : ''}</p>`;
          return;
        }
      } catch (e) { console.warn('Failed to load members', e); }
      list.innerHTML = '<p class="small-muted">Failed to load members.</p>';
    }

    // Poll presences every 30s when this page is open
    let _presencePoll = null;
    async function refreshPresences() {
      try {
        const res = await fetch(`/api/guild-presences/${encodeURIComponent(serverId)}`);
        if (res.ok) {
          const body = await res.json(); const pres = body.presences || body || [];
          pres.forEach(p => {
            const id = p.id;
            const status = (p.status || p.presence || 'unknown').toLowerCase();
            // update any dots
            document.querySelectorAll(`.status-dot[data-member-id="${id}"]`).forEach(el => {
              el.className = 'status-dot status-' + status;
              el.title = 'Status: ' + status;
            });
          });
        }
      } catch (e) { /* ignore */ }
    }

    (async () => {
      await detectServerAuth(); await renderPlugins(); // start polling after initial render
      try { await refreshPresences(); } catch (e) { }
      if (_presencePoll) clearInterval(_presencePoll); _presencePoll = setInterval(refreshPresences, 30_000);
    })();


  </script>
</body>

</html>